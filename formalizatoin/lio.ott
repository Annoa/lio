metavar x ::=   {{ com  term variable }} 
                {{ lex alphanum }} 


metavar a ::= {{ com memory location }}
              {{ lex alphanum }} 


indexvar i ::= {{ com integer }}

indexvar n ::= {{ com integer }}

grammar

l, c :: 'l_' ::=                                {{ com label                 }}
  | lubPrim l l' ::   :: VLub                   {{ com primitive label join  }}
                                                {{ tex [[l]] \sqcup_p [[l']] }}

v :: 'v_' ::=                                   {{ com value                 }}
  | true         ::   :: VTrue                  {{ com Boolean true          }}
  | false        ::   :: VFalse                 {{ com Boolean false         }}
  | ()           ::   :: VUnit                  {{ com unit value            }}
  | l            ::   :: VLabel                 {{ com label                 }}
  | a            :: M :: VAddress               {{ com address               }}
  | x            ::   :: VVar                   {{ com variable              }}
  | \ x . t      ::   :: VLam                   {{ com lambda                }}
  | ( t1 , t2 )  ::   :: VTuple                 {{ com tuple                 }}
  | fix t        ::   :: VFix                   {{ com fixpoint              }}
  | Lb t1 t2     ::   :: VLabeled               {{ com labeled               }}
  | LIO t        :: M :: VLIOVal                {{ com \textsf{LIO} value    }}
                                                {{ tex ([[t]])^\textsf{LIO}  }}
  | hole         :: M :: VHole                  {{ com hole                  }}
                                                {{ tex \bullet               }}
                                                                             
t :: 't_'  ::=                                  {{ com term                  }}
  | true         ::   :: VTrue                  {{ com Boolean true          }}
  | false        ::   :: VFalse                 {{ com Boolean false         }}
  | ()           ::   :: VUnit                  {{ com unit value            }}
  | l            ::   :: VLabel                 {{ com label                 }}
  | a            :: M :: VAddress               {{ com address               }}
  | x            ::   :: VVar                   {{ com variable              }}
  | \ x . t      ::   :: VLam (+ bind x in t +) {{ com lambda                }}
  | ( t1 , t2 )  ::   :: VTuple                 {{ com tuple                 }}
  | fix t        ::   :: VFix                   {{ com fixpoint              }}
  | Lb t1 t2     ::   :: VLabeled               {{ com labeled               }}
  | LIO t        :: M :: VLIOVal                {{ com \textsf{LIO} value    }}
                                                {{ tex ([[t]])^\textsf{LIO}  }}
  | hole         :: M :: VHole                  {{ com hole                  }}
                                                {{ tex \bullet               }}

  | t t'                  ::   :: App           {{ com app                   }}
  | proj i  t             ::   :: Proj          {{ com proj                  }}
                                                {{ tex \pi_[[i]] [[t]]       }}
  | if t1 then t2 else t3 ::   :: IfEl          {{ com conditional           }}
  | let x = t in t'       ::   :: Let           (+ bind x in t               +)
                                                (+ bind x in t'              +)
                                                {{ com let                   }}
  | return t              ::   :: Return        {{ com return                }}
  | bind t t'             ::   :: Bind          {{ com bind                  }}
                                             {{ tex [[t]] >\!\!>\!\!= [[t']] }}
  | label t t'            ::   :: Label         {{ com label                 }}
  | unlabel t             ::   :: UnLabel       {{ com unlabel               }}
  | toLabeled t1 t2       ::   :: ToLabeled     {{ com execute action        }}
  | newLIORef t1 t2       ::   :: NewLIORef     {{ com new reference         }}
  | readLIORef t1         ::   :: ReadLIORef    {{ com read reference        }}
  | writeLIORef t1 t2     ::   :: WriteLIORef   {{ com write reference       }}
  | lowerClr t            ::   :: LowerClr      {{ com lower clearance       }}
  | getLabel              ::   :: GetLabel      {{ com get current label     }}
  | getClearance          ::   :: GetClearance  {{ com get current clearance }}
  | labelOf t             ::   :: LabelOf       {{ com get label of value    }}
  | lub t1 t2             ::   :: Join          {{ com least upper bound     }}
                                                {{ tex [[t1]] \sqcup [[t2]] }}
  | ( t )                 :: S :: Paren         {{ icho [[t]]                }} 
  | { t / x } t'          :: M :: Tsub        
                                      {{ icho (tsubst_t [[t]] [[x]] [[t']]) }}

M :: 'M_'  ::=                                  {{ com memory                }}
   | mem_empty            ::   :: MemEmpty      {{ com empty set             }}
                                                {{ tex \emptyset             }}
   | ( a , t ) , M        ::   :: ConcatElem    {{ com element addition      }}
   | update M a t         ::   :: Update        {{ com memory update         }}
                                        {{ tex [[M]] [ [[a]] \mapsto [[t]] ] }}

p :: 'p_'  ::=                                  {{ com program               }}
  | <| l , c , M , t |>   ::   :: Program       {{ com environment and term  }}

formula :: 'formula_' ::=          
  | judgement           ::   :: judgement
  | [| formula |]       ::   :: denotational
  | x = x'              ::   :: eqvx
  | t = t'              ::   :: eqvt
  | M = M'              ::   :: eqvM
  | l = l'              ::   :: eqvl
  | l [= l'             ::   :: canFlowTo
  | elem ( a , t ) M    ::   :: atInM  {{ tex ([[a]], [[t]]) \in [[M]] }}
  | fresh a             ::   :: aFresh {{ tex [[a]]\ \mathit{fresh}  }}

terminals :: 'terminals_' ::=
  | \            ::  :: lambda   {{ tex \lambda }}
  | -->          ::  :: reduce   {{ tex \longrightarrow }}
  | =>           ::  :: bigstep  {{ tex \longrightarrow^* }}
  | ~>           ::  :: preduce  {{ tex \leadsto }}
  | <|           ::  :: langle   {{ tex \langle }}
  | |>           ::  :: rangle   {{ tex \rangle }}
  | [=           ::  :: leq      {{ tex \sqsubseteq }}
  | [|           ::  :: llbacket {{ tex [\![}}
  | |]           ::  :: rrbacket {{ tex ]\!]}}

subrules
  v <:: t

defns
Jop :: '' ::=

 defn
 p1 => p2 :: ::bigstep::'' {{ com [[p1]] takes big step reduces to [[p2]]}} by

    <| l, c, M, t |> --> <| l', c', M', t' |>
    ------------------------------------------ :: onestep
    <| l, c, M, t |> => <| l', c', M', t' |>


    ------------------------------------ :: done
    <| l, c, M, v |> => <| l, c, M, v |>
    

 defn
 t1 ~> t2 :: ::preduce::'' {{ com pure [[t1]] reduces to [[t2]]}} by



    t1 ~> t1'
    ------------- :: appCtx
    t1 t ~> t1' t

    -----------------------  :: app
    (\x.t1) t2 ~>  {t2/x}t1

    ------------------ :: fix
    fix t ~> t (fix t)

    t ~> t'
    --------------------- :: projCtx
    proj i t ~> proj i t'

    ---------------------- :: proj
    proj i (t1 , t2) ~> ti

    t1 ~> t1'
    ------------------------------------------------  :: ifCtx
    if t1 then t2 else t3 ~> if t1' then t2 else t3

    ------------------------------  :: ifTrue
    if true then t2 else t3 ~> t2

    -------------------------------  :: ifFalse
    if false then t2 else t3 ~> t3

    -----------------------------  :: let
    let x = t1 in t2 ~> {t1/x}t2

    t1 ~> t1'
    ------------------------  :: lubCtxL
    lub t1 t2 ~> lub t1' t2

    t2 ~> t2'
    -----------------------  :: lubCtxR
    lub l1 t2 ~> lub l1 t2'

    --------------------------  :: lub
    lub l1 l2 ~> lubPrim l1 l2

    t ~> t'
    -------------------------------------------------------------------- :: labelOfCtx1
    labelOf t ~> labelOf t'

    t1 ~> t1'
    -------------------------------------------------------------------- :: labelOfCtx2
    labelOf (Lb t1 t2) ~> labelOf (Lb t1' t2)

    --------------------------------------------------  :: labelOf
    labelOf (Lb l1 t2) ~> l1



 defn
 p1 --> p2 :: ::reduce::'' {{ com [[p1]] reduces to [[p2]]}} by

    ----------------------------------------------  :: return
    <|l, c, M, return t |> --> <|l, c, M, LIO t |>

    <|l, c, M, t1|> --> <|l', c', M', t1'|>
    ------------------------------------------------------  :: bindCtx
    <|l, c, M, bind t1 t2|> --> <|l', c', M', bind t1' t2|>

    ----------------------------------------------------  :: bind
    <|l, c, M, bind (LIO t1) t2|> --> <|l, c, M, t2 t1|>


    t1 ~> t1'
    ------------------------------------------------------  :: labelCtx
    <|l, c, M, label t1 t2|> --> <|l, c, M, label t1' t2|>

    l  [= l1
    l1 [= c    
    -----------------------------------------------------------  :: label
    <|l, c, M, label l1 t2|> --> <|l, c, M, return (Lb l1 t2)|>

    t ~> t'
    --------------------------------------------------  :: unlabelCtx1
    <|l, c, M, unlabel t|> --> <|l, c, M, unlabel t'|>

    t1 ~> t1'
    -------------------------------------------------------------------- :: unlabelCtx2
    <|l, c, M, unlabel (Lb t1 t2)|> --> <|l, c, M, unlabel (Lb t1' t2)|>

    lub l l1 ~> l2
    l2 [= c
    ---------------------------------------------------------  :: unlabel
    <|l, c, M, unlabel (Lb l1 t2)|> --> <|l2, c, M, return t2|>

    t1 ~> t1'
    -------------------------------------------------------------- :: toLabeledCtx
    <|l, c, M, toLabeled t1 t2|> --> <|l, c, M, toLabeled t1' t2|>

    l  [= l1
    l1 [= c
    <|l, c, M, t|> => <|l', c', M', return t'|>
    l' [= l1
    -------------------------------------------------------------- :: toLabeled
    <|l, c, M, toLabeled l1 t|> --> <|l, c, M', label l1 t'|>

    t1 ~> t1'
    --------------------------------------------------------------  :: newLIORefCtx
    <|l, c, M, newLIORef t1 t2|> --> <|l, c, M, newLIORef t1' t2|>

    l [= l1
    l1 [= c
    fresh a
    M' = (a, Lb l1 t2) , M
    ------------------------------------------------------  :: newLIORef
    <|l, c, M, newLIORef l1 t2|> --> <|l, c, M', return a|>

    t ~> t'
    -------------------------------------------------------  :: readLIORefCtx
    <|l, c, M, readLIORef t|> --> <|l, c, M, readLIORef t'|>

    elem (a, Lb l1 t2) M
    lub l l1 ~> l' 
    l' [= c
    ----------------------------------------------------  :: readLIORef
    <|l, c, M, readLIORef a|> --> <|l', c, M, return t2|>

    t1 ~> t1'
    ------------------------------------------------------------------  :: writeLIORefCtx
    <|l, c, M, writeLIORef t1 t2|> --> <|l, c, M, writeLIORef t1' t2|>

    elem (a, Lb l1 t2) M
    lub l l1 ~> l' 
    l' [= c
    M' = update M a (Lb l1 t2')
    ---------------------------------------------------------  :: writeLIORef
    <|l, c, M, writeLIORef a t2'|> --> <|l', c, M', return ()|>
  
    t ~> t'
    -----------------------------------------------------  :: lowerClrCtx
    <|l, c, M, lowerClr t |> -->  <|l, c, M, lowerClr t'|>

    l  [= c'
    c' [= c
    -----------------------------------------------------  :: lowerClr
    <|l, c, M, lowerClr c'|> -->  <|l, c', M, return ()|>

    ------------------------------------------------  :: getLabel
    <|l, c, M, getLabel|> -->  <|l, c, M, return l|>

    ----------------------------------------------------  :: getClearance
    <|l, c, M, getClearance|> -->  <|l, c, M, return c|>
