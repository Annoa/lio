\documentclass[10pt]{article} 
\usepackage[margin=.5in]{geometry} 
\usepackage{amsmath,amssymb,amsfonts,amsthm,stmaryrd,txfonts, mathabx}
\usepackage{float}
\usepackage{mathpartir}

\date{\today}
 
\newcommand{\fix}{\texttt{fix}}
\newcommand{\lvalue}{\texttt{lvalue}}
\newcommand{\return}{\texttt{return}}
\newcommand{\bind}{\texttt{>>=}}
\newcommand{\seq}{\texttt{>>}}
\newcommand{\Lvalue}{\texttt{Lvalue}}
\newcommand{\Bool}{\texttt{Bool}}
\newcommand{\true}{\texttt{true}}
\newcommand{\false}{\texttt{false}}
\newcommand{\ifel}[3]{\texttt{if}\ #1\ \texttt{then}\ #2\ \texttt{else}\ #3}
\newcommand{\letbind}[3]{\texttt{let}\ #1=#2\ \texttt{in}\ #3}
\newcommand{\Lv}{\texttt{Lv}}
\newcommand{\lub}{\sqcup}
\newcommand{\glb}{\sqcap}
\newcommand{\labelOf}{\mathcal{L}}
\newcommand{\lL}{\texttt{L}}
\newcommand{\lH}{\texttt{H}}
\newcommand{\Adv}{\mathcal{A}}
\newcommand{\seal}{\texttt{seal}}
\newcommand{\open}{\texttt{open}}
\newcommand{\nolabel}{\obslash}
\newcommand{\unit}{\texttt{()}}
\newcommand{\get}{\texttt{get}}

\floatstyle{ruled}
\newfloat{typerules}{htbp}{lop} \floatname{typerules}{Typing Rule}
\newfloat{sos}{htbp}{lop} \floatname{sos}{Operational Semantics}
\newfloat{language}{htbp}{lop} \floatname{language}{Language}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\theoremstyle{definition}
\newtheorem{definition}{Definition}

\begin{document} 

\begin{language}
\begin{align*}
\textrm{Lattice:}             && \mathbb{L} &= (L, \sqsubseteq, \lub, \glb, \bot, \top)                 \\
\\
\textrm{Label:}               && l &\\
\\
\textrm{Value:}               && v    &\Coloneqq   x                    \\ % variable
                              &&      &\ |\  \lambda x.e                \\ % abstraction
                              &&      &\ |\  (e, e)                     \\ % tuple
                              &&      &\ |\  \Lv\ e\ e                  \\ % value of type Lvalue
                              &&      &\ |\  \true                      \\ % value of type Bool
                              &&      &\ |\  \false                     \\ % value of type Bool
                              &&      &\ |\  l                          \\ % label
                              &&      &\ |\  \fix\ e                    \\ % recursion
\\
\textrm{Term:}                && e    &\Coloneqq  v                     \\ % values
                              &&      &\ |\  e\ e                       \\ % application
                              &&      &\ |\  \ifel{e}{e}{e}             \\ % recursion
                              &&      &\ |\  \letbind{x}{e}{e}          \\ % let-bindings
                              &&      &\ |\  \pi_i\ e                   \\ % \pi_1 = fst, \pi_2 = snd
                              &&      &\ |\  \return\ e                 \\ % return
                              &&      &\ |\  \return^\prime\ e\ e       \\ % return
                              &&      &\ |\  e\ \bind\ e                \\ % bind two expressions
                              &&      &\ |\  e\ \seq\ e                 \\ % sequence two expressions
                              &&      &\ |\  \seal\ e\ e                \\ % seal
                              &&      &\ |\  \open\ e                   \\ % open
                              &&      &\ |\  e\ \lub\ e                 \\ % lub
                              &&      &\ |\  e\ \glb\ e                 \\ % glb
\\
\textrm{Type:}                && \tau &\Coloneqq  \tau\rightarrow\tau   \\ % function
                              &&      &\ |\  (\tau,\tau)                \\ % tuple
                              &&      &\ |\  \Bool                      \\ % bool
                              &&      &\ |\  \ell                     \\ % Label
                              &&      &\ |\  \Lvalue\ \ell\ e           \\ % Lvalue
                              &&      &\ |\  \unit                      \\ % Unit
\end{align*}
\caption{Simple language, hiding underlying state label and clearance}
\end{language}
\begin{enumerate}
\item $\Lv\ e\ e$ is the runtime representation of a labeled value and it does not appear in the source.
\item The typing judgements are standard, $\Gamma : \textrm{Term} \rightarrow \textrm{Type}$.
\item The function $\mathcal{L} : \textrm{Label} \rightarrow \mathbb{L}$ maps a labels to elements of latice $\mathbb{L}$, i.e., $\mathcal{L}\llbracket l\rrbracket \in \mathbb{L}\cup\{\bot,\top\}$. The label and lattice definitions may be definited arbitrarily as long as $\mathcal{L}$ is bijective. Additionally, $\mathcal{L}$ is homorphically be defined over label operations, so 
$\mathcal{L}\llbracket l_1 \lub\ l_2\rrbracket = \mathcal{L}\llbracket l_1 \rrbracket \lub \mathcal{L} \llbracket l_2\rrbracket$, and similarly $\mathcal{L}\llbracket l_1 \glb\ l_2\rrbracket = \mathcal{L}\llbracket l_1 \rrbracket \glb \mathcal{L} \llbracket l_2\rrbracket$.
\end{enumerate}


\begin{typerules}
\begin{align}
\inferrule{\Gamma(x)=\tau} 
     {\Gamma \vdash x : \tau}\tag{T-Var}
\\
\inferrule{\Gamma[x \mapsto \tau_1] \vdash e : \tau_2} 
     {\Gamma \vdash \lambda x.e : \tau_1 \rightarrow \tau_2}\tag{T-Abs}
\\
\inferrule{\Gamma \vdash e_1 : \tau_1 \\ \Gamma \vdash e_2 : \tau_2 }
     {\Gamma \vdash (e_1,e_2) : (\tau_1, \tau_2)}\tag{T-Tup}
\\
\inferrule{\Gamma \vdash e_1 : \ell \\ \Gamma \vdash e_2 : \tau}
     {\Gamma \vdash \Lv\ e_1\ e_2 : \Lvalue\ \ell\ \tau}\tag{T-Lv}
\\
\inferrule{}{\vdash \true : \Bool}\tag{T-True}
\\
\inferrule{}{\vdash \false : \Bool}\tag{T-False}
\\
\inferrule{}{\vdash l : \ell}\tag{T-Label}
\\
\inferrule{\Gamma \vdash e : \tau \rightarrow \tau}
     {\Gamma \vdash \fix\ e : \tau}\tag{T-Fix}
\\
\inferrule{\Gamma \vdash e_1 : \tau_1 \rightarrow \tau_2 \\ \Gamma \vdash e_2 : \tau_1}
     {\Gamma \vdash e_1\ e_2 : \tau_2}\tag{T-App}
\\
\inferrule{\Gamma \vdash e_1 : \Bool \\ \Gamma \vdash e_2 : \tau \\ \Gamma \vdash e_3 : \tau}
     {\Gamma \vdash \ifel{e_1}{e_2}{e_3} : \tau}\tag{T-IfEl}
\\
\inferrule{\Gamma \vdash e_1 : \tau_1 \\ \Gamma [x \mapsto \tau_1] \vdash e_2 : \tau_2}
     {\Gamma \vdash \letbind{x}{e_1}{e_2} : \tau_2}\tag{T-Let}
\\
\inferrule{\Gamma \vdash e : (\tau_1, \tau_2)}
     {\Gamma \vdash \pi_i\ e : \tau_i}
     {(i\in\{1,2\})}\tag{T-Proj}
\\
\inferrule{\Gamma \vdash e : \tau}
     {\Gamma \vdash \return\ e : \Lvalue\ \ell\ \tau}\tag{T-Ret?}
\\
\inferrule{\Gamma \vdash e_1 : \tau \\ \Gamma \vdash e_2 : \ell}
     {\Gamma \vdash \return^\prime\ e_1\ e_2: \Lvalue\ \ell\ \tau}\tag{T-Ret$^\prime$}
\\
\inferrule{\Gamma \vdash e_1 : \Lvalue\ \ell\ \tau_1 \\ \Gamma \vdash e_2 : \tau_1 \rightarrow \Lvalue\ \ell\ \tau_2}
     {\Gamma \vdash e_1\ \bind\ e_2 : \Lvalue\ \ell\ \tau_2}\tag{T-Bind}
\\
\inferrule{\Gamma \vdash e_1 : \Lvalue\ \ell\ \tau_1 \\ \Gamma \vdash e_2 : \Lvalue\ \ell\ \tau_2}
     {\Gamma \vdash e_1\ \seq\ e_2 : \Lvalue\ \ell\ \tau_2}\tag{T-Seq}
\\
\inferrule{\Gamma \vdash e_1 : \tau \\ \Gamma \vdash e_2 : \ell}
     {\Gamma \vdash \seal\ e_1\ e_2: \Lvalue\ \ell\ \tau}\tag{T-Seal}
\\
\inferrule{\Gamma \vdash e : \Lvalue\ \ell\ \tau}
     {\Gamma \vdash \open\ e : \tau}\tag{T-Open}
\\
\inferrule{\Gamma \vdash e_1 : \ell\\ \Gamma \vdash e_2 : \ell}
     {\Gamma \vdash e_1\ \lub\ e_2 : \ell}\tag{T-Join}
\\
\inferrule{\Gamma \vdash e_1 : \ell\\ \Gamma \vdash e_2 : \ell}
     {\Gamma \vdash e_1\ \glb\ e_2 : \ell}\tag{T-Meet}
\end{align}
\caption{Simple type rules, hiding underlying state label and clearance}
\end{typerules}

\pagebreak

\begin{sos}
\begin{align*}
&&E&   ::=  [\cdot]                    
       \ |\  E\ e                       
       \ |\  (E, e)                     
       \ |\  (v, E)                     
       \ |\  \ifel{E}{e}{e}
       \ |\  \letbind{x}{E}{e}
       \ |\  \pi_i\ E                     
       \ |\  \seal\ E\ l                
       \ |\  \open\ E                 
       \\
&&&    \ |\  \return\ E                 
       \ |\  \return^\prime\ E\ l          
       \ |\  E\ \diamond\ e                
       \ |\  v\ \diamond\ E, \textrm{where }\diamond = \{\bind, \seq, \lub, \glb\}
       \\
\\                                                                                                    
&&&E[(\lambda x.e_1)\ e_2]                         \longrightarrow E[[e_2/x]e_1]          \tag{E-App}    \\
&&&E[\fix\ e]                                      \longrightarrow E[e\ \fix\ e]          \tag{E-Fix}    \\
&&&E[\ifel{\true}{e_1}{e_2}]                       \longrightarrow E[e_1]                 \tag{E-IfTrue} \\
&&&E[\ifel{\false}{e_1}{e_2}]                      \longrightarrow E[e_2]                 \tag{E-IfFalse}\\
&&&\inferrule{e_1 \longrightarrow {e_1}^\prime}
   {E[\letbind{x}{e_1}{e_2}]                       \longrightarrow E[\letbind{x}{{e_1}^\prime}{e_2}]}         \tag{E-Let}    \\
&&&E[\letbind{x}{v}{e}]                            \longrightarrow E[[v/x]e]                                  \tag{E-LetVal} \\
&&&E[\pi_i\ (e_1,e_2)]                             \longrightarrow E[e_i]                 \tag{E-Proj}   \\
&&&E[\return\ e]                                   \longrightarrow E[\return^\prime\ e\ l_\bot] \tag{E-Ret}    \\
&&&E[\return^\prime\ e\ l]                         \longrightarrow E[\Lv\ l\ e]           \tag{E-Ret$^\prime$}  \\
&&&\inferrule{[e_1/x]e_2 \longrightarrow^* \Lv\ l_2\ {e_2}^\prime}
      {E[\Lv\ l_1\ e_1\ \bind\ \lambda x.e_2]      \longrightarrow E[[e_1/x]e_2\ \bind\ \lambda x.\return^\prime\ x\ (l_1\lub l_2)]}\tag{E-Bind} \\
&&&E[\Lv\ l_1\ e_1\ \bind\ \lambda x.\return^\prime\ x\ l_2] \longrightarrow E[\Lv\ (l_1\lub l_2)\ e_1]\tag{E-Runit}\\
&&&E[\Lv\ l_1\ e_1\ \seq\ e_2]                     \longrightarrow E[e_2\ \bind\ \lambda x.\return\ x]\tag{E-Seq} \\
&&&\inferrule{\mathcal{L}\llbracket l_3\rrbracket = \mathcal{L}\llbracket l_1 \lub l_2\rrbracket}
            {E[l_1\ \lub\ l_2] \longrightarrow E[l_3]} \tag{E-Join}\\
&&&\inferrule{\mathcal{L}\llbracket l_3\rrbracket = \mathcal{L}\llbracket l_1 \glb l_2\rrbracket}
           {E[l_1\ \glb\ l_2] \longrightarrow E[l_3]} \tag{E-Meet}\\
\end{align*}
\caption{Semantics for pure terms.}
\end{sos}

\pagebreak

\begin{sos}
\begin{align*}
&&&\inferrule{l \sqsubseteq l_1 \sqsubseteq c}
      {E_l^c[\seal\ e\ l_1] \longrightarrow E_l^c[\Lv\ l\ e]} \tag{E-Seal}  \\
&&&\inferrule{l^\prime = l \lub l_1 \\ l^\prime \sqsubseteq c}
      {E_l^c[\open\ \Lv\ l_1\ e_1] \longrightarrow E_{l^\prime}^c[e_1]} \tag{E-Open} 
\end{align*}
\caption{Semantics for terms with side effects; \texttt{Lref} case}
\end{sos}

The parametrized evaluation contexts directly translate to non-parametrized evalution contexts.
For example,
\begin{equation*}
\inferrule{l \sqsubseteq l_1 \sqsubseteq c}{E_l^c[\seal\ e\ l_1] \longrightarrow E_l^c[\Lv\ l\ e]}
\end{equation*}
can be rewritten to
\begin{equation*}
E_l^c[\seal\ e\ l_1] \longrightarrow E_l^c[\get\ \bind \lambda(l,c).\ifel{ l \sqsubseteq l_1 }{
(\ifel{l_1 \sqsubseteq c}{\return\ \Lv\ l\ e}{\texttt{lerror}\ l \textrm{``$\ldots$''}})
}{(\texttt{lerror}\ l\ \textrm{``$\ldots$''})}]
\end{equation*}
where bind and return operate on the underlying monad, and the error function returns a labeled error.





\begin{sos}
\begin{align*}
&&&E_l^c[\return\ e] \longrightarrow E_l^c[\Lv\ l\ e] \tag{E-Ret}  \\
&&&\inferrule{{l_1}^\prime=l\lub l_1 \\ {l_1}^\prime \sqsubseteq c}
      {E_l^c[\return^\prime\ e\ l_1] \longrightarrow E_l^c[\Lv\ l_1\ e]} \tag{E-Ret$^\prime$}  \\
&&&\inferrule{E_l^c[[e_1/x]e_2] \longrightarrow^* E_{l^\prime}^c[\Lv\ l_2\ {e_2}^\prime]\\ {l_2}^\prime=l_1\lub l_2 \lub l^\prime \\ {l_2}^\prime\sqsubseteq c}
      {E_l^c[\Lv\ l_1\ e_1\ \bind\ \lambda x.e_2]   \longrightarrow E_{l^\prime}^c[[e_1/x]e_2\ \bind\ \lambda x.\return^\prime\ x\ {l_2}^\prime]}\tag{E-Bind} \\
&&&\inferrule{{l_1}^\prime = l_1\lub l_2 \\ {l_1}^\prime \sqsubseteq c}{E_l^c[\Lv\ l_1\ e_1\ \bind\ \lambda x.\return^\prime\ x\ l_2] \longrightarrow E_l^c[\Lv\ l_1^\prime\ e_1]}\tag{E-Runit}\\
&&&\inferrule{{l_1}^\prime=l\lub l_1 \\ {l_1}^\prime \sqsubseteq c}
      {E_l^c[\seal\ e\ l_1] \longrightarrow E_l^c[\Lv\ l_1\ e]} \tag{E-Seal}  \\
&&&\inferrule{l^\prime = l \lub l_1 \\ l^\prime \sqsubseteq c}
      {E[\open\ \Lv\ l_1\ e_1] \xrightarrow[l\rightarrow l^\prime]{c\rightarrow c} E[e_1]} \tag{E-Open}  \\
\end{align*}
\caption{Semantics for terms with side effects; \texttt{Lvalue} case}
\end{sos}


\pagebreak
\subsection{Language properties}

\begin{lemma}[Preservation]
If $\vdash e : \tau$ and $\Delta^{c\rightarrow c^\prime}_{l\rightarrow l^\prime} \vdash e : l$ and $e \longrightarrow e^\prime$ then $\vdash e^\prime : \tau$ and $\Delta^{c^\prime\rightarrow c^\second}_{l^\prime\rightarrow l^\second} \vdash e^\prime : l$.
\end{lemma}

\begin{lemma}[Preservation-Alt]
If $\vdash e : \tau$ and $e \xrightarrow[l\rightarrow l^\prime]{c\rightarrow c^\prime} e^\prime$ then $\vdash e^\prime : \tau$.
\end{lemma}
In other words, a well-typed term taking an evaluation step results in a term that is also well-typed.

\begin{lemma}[Progress]
If $\vdash e : \tau$ and $\Delta^{c\rightarrow c^\prime}_{l\rightarrow l^\prime} \vdash e : l$, then $e \longrightarrow v$ and $\Delta^{c^\prime\rightarrow c^\second}_{l^\prime\rightarrow l^\second} \vdash v : l$, or there exists $e^\prime$ such that $e \longrightarrow e^\prime$.
\end{lemma}

\begin{lemma}[Progress-Alt]
If $\vdash e : \tau$ then $e \xrightarrow[l\rightarrow l^\prime]{c\rightarrow c^\prime} v$, or there exists $e^\prime$ such that $e \xrightarrow[l\rightarrow l^\prime]{c\rightarrow c^\prime} e^\prime$.
\end{lemma}
In other words, a closed and well-typed term is not stuck.

\begin{theorem}[Type safety]
If $\vdash e : \tau$ and $\Delta^{c\rightarrow c^\prime}_{l\rightarrow l^\prime} \vdash e : l$ and $e \longrightarrow^* e^\prime$ then $e^\prime$ is not stuck.
\end{theorem}

\begin{theorem}[Type safety-Alt]
If $\vdash e : \tau$ and $e \xrightarrow[l\rightarrow l^\prime]{c\rightarrow c^\prime}^* e^\prime$ then $e^\prime$ is not stuck.
\end{theorem}

\begin{lemma}[Type preservation under substitution]
If $\Gamma[x \mapsto \tau] \vdash e : \tau'$ and $\Gamma \vdash v : \tau$ then $\Gamma \vdash [v/x]e : \tau'$.
\end{lemma}

\textbf{OLD:}
\begin{definition}[Low-equivalence]
Two inputs, each consisting of a pair of values with labels $\ell, \ell'$ such that $ \ell' \not\sqsubseteq\ell$, are equivalent according to the equivalence relation $=_L$  if they agree on the low values. Specifically, for inputs $e_1, e_2$:
\begin{equation*}
\inferrule{(\Gamma \vdash e_j : (\Lvalue\ \ell'\ \tau'_i, \Lvalue\ \ell\ \tau_i))_{j=1,2} \\ (e_j\longrightarrow^* v_j)_{j=1,2}\\ \pi_2\ v_1 = \pi_2\ v_2}
{e_1 =_L e_2}
\end{equation*}
\end{definition}

\begin{theorem}[Non-interference]
Given labels $\ell, \ell'$ such that $ \ell' \not\sqsubseteq\ell$, an attacker $\Adv$ with clearance $c_\Adv$ such that $\ell \sqsubseteq c_\Adv$ and $\ell' \not\sqsubseteq c_\Adv$, and a pure computation $e$ such that $\Gamma \vdash e : (\Lvalue\ \ell'\ \tau'_i, \Lvalue\ \ell\ \tau_i) \rightarrow (\Lvalue\ \ell'\ \tau'_o, \Lvalue\ \ell\ \tau_o)$, then
\begin{equation*}
\forall e_1 e_2.(\Gamma \vdash e_j : (\Lvalue\ \ell'\ \tau'_i,\Lvalue\ \ell\ \tau_i))_{j=1,2}
\land e_1 =_L e_2 \land  e\ e_1 \longrightarrow^* v_1 \land e\ e_2 \longrightarrow^* v_2\ \Rightarrow v_1 =_L v_2.
\end{equation*}
\end{theorem}

In other words, given two inputs, each consisting of a pair of values with a public and secret labels, the result of the computation as observed by the attacker (at label level $c_\Adv$) is not distinguishable.


\subsection{Example:} 
\begin{equation*}
                 \Lv\ \lL\ 1\ \bind\ \lambda x.
                  \Lv\ \lH\ 2\ \bind\ \lambda y.
                  \return\ (x + y), \textrm{for }\ell_\bot \sqsubseteq \lL \sqsubseteq \lH \sqsubseteq \top\\
\end{equation*}
{\bf Solution: }
\begin{align*}
                & \Lv\ \lL\ 1\ \bind\ \lambda x.
                  \Lv\ \lH\ 2\ \bind\ \lambda y.
                  \return\ (x + y) \\
\longrightarrow &\Lv\ \lH\ 2\ \bind\ \lambda y.  \return\ (1 + y)\longrightarrow^* \Lv\ \lH\ 3 
    \Rightarrow   \Lv\ \lH\ 2\ \bind\ \lambda y.
                  \return\ (1 + y)\
                  \bind\ \lambda x.\return'\ x\ (\lL\lub\lH)\\
\longrightarrow & \return\ (1 + 2)\ \bind\ \lambda x.\return'\ x\ (\lL\lub\lH) \longrightarrow^* \Lv\ \lH\ 3 
    \Rightarrow   \return\ (1 + 2)\
                  \bind\ \lambda x.\return'\ x\ (\lL\lub\lH)\
                  \bind\ \lambda x.\return'\ x\ (\lH\lub\lH)\\
\longrightarrow & \return'\ (1 + 2)\ \ell_\bot\
                  \bind\ \lambda x.\return'\ x\ (\lL\lub\lH)\
                  \bind\ \lambda x.\return'\ x\ (\lH\lub\lH)\\
\longrightarrow & \Lv\ \ell_\bot\ (1 + 2)\ 
                  \bind\ \lambda x.\return'\ x\ (\lL\lub\lH)\
                  \bind\ \lambda x.\return'\ x\ (\lH\lub\lH)\\
\longrightarrow & \Lv\ (\ell_\bot\lub\lL\lub\lH)\ (1 + 2)\ 
                  \bind\ \lambda x.\return'\ x\ (\lH\lub\lH)\\
\longrightarrow & \Lv\ (\ell_\bot\lub\lL\lub\lH\lub\lH)\ (1 + 2)\\
\longrightarrow & \Lv\ \lH\ (1 + 2)\\
\longrightarrow & \Lv\ \lH\ 3\\
\end{align*}
\end{document} 
