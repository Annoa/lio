\documentclass[10pt]{article} 
%\usepackage[margin=.5in]{geometry} 
\usepackage{float}
\usepackage{amsmath,amssymb,amsfonts,amsthm,stmaryrd,txfonts, mathabx}
\usepackage{float}
\usepackage{mathpartir}
\pagestyle{empty}

\date{\today}
 
\newcommand{\fix}{\texttt{fix}}
\newcommand{\lvalue}{\texttt{lvalue}}
\newcommand{\return}{\texttt{return}}
\newcommand{\bind}{\texttt{>>=}}
\newcommand{\seq}{\texttt{>>}}
\newcommand{\Lvalue}{\texttt{Lvalue}}
\newcommand{\Bool}{\texttt{Bool}}
\newcommand{\true}{\texttt{true}}
\newcommand{\false}{\texttt{false}}
\newcommand{\ifel}[3]{\texttt{if}\ #1\ \texttt{then}\ #2\ \texttt{else}\ #3}
\newcommand{\letbind}[3]{\texttt{let}\ #1=#2\ \texttt{in}\ #3}
\newcommand{\Lv}{\texttt{Lv}}
\newcommand{\lub}{\sqcup}
\newcommand{\glb}{\sqcap}
\newcommand{\labelOf}{\mathcal{L}}
\newcommand{\lL}{\texttt{L}}
\newcommand{\lM}{\texttt{M}}
\newcommand{\lH}{\texttt{H}}
\newcommand{\Adv}{\mathcal{A}}
\newcommand{\seal}{\texttt{seal}}
\newcommand{\open}{\texttt{open}}
\newcommand{\nolabel}{\obslash}
\newcommand{\unit}{\texttt{()}}
\newcommand{\getS}{\texttt{get}}
\newcommand{\putS}{\texttt{put}}
\newcommand{\evalLIO}{\texttt{evalLIO}}
%\newcommand{\evalrel}[4]{{}^_{#1}^{#2}{\longrightarrow}_{#3}^{#4}\ } %#3\xrightarrow[{#1 \quad #3}]{{#2 \quad #4}}}
\newcommand{\evalrel}[4]{\xrightarrow[{#1 \quad #3}]{{#2 \quad #4}}}
\newcommand{\transevalrel}[4]{{\xrightarrow[{#1 \quad #3}]{{#2 \quad #4}}}^{*}}

\newcommand{\LIO}{\texttt{LIO}}
\newcommand{\LIOp}{\texttt{LIO'}}
\newcommand{\IO}{\texttt{IO}}
\newcommand{\returnLIOp}{\texttt{return}^\texttt{\tiny LIO'}}
\newcommand{\bindLIOp}{\texttt{>>=}^\texttt{\tiny LIO'}}
\newcommand{\seqLIO}{\texttt{>>}^\texttt{\tiny LIO'}}
\newcommand{\lioValp}[1]{(#1)^\texttt{\tiny LIO'}}

\newcommand{\tref}[1]{\textrm{#1}}

\newcommand{\withLblClr}{\texttt{withLblClr}}
\newcommand{\store}{\sigma_\ell}
\newcommand{\lbl}{\texttt{lbl}}
\newcommand{\clr}{\texttt{clr}}

\newcommand{\well}[2]{\mathcal{W}\llbracket #1,  #2 \rrbracket}
\newcommand{\tT}{\mathbb{T}}
\newcommand{\tF}{\mathbb{F}}

\floatstyle{ruled}
\newfloat{typerules}{htbp}{lop} \floatname{typerules}{Typing Rule}
\newfloat{sos}{htbp}{lop} \floatname{sos}{Operational Semantics}
\newfloat{language}{htbp}{lop} \floatname{language}{Language}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\theoremstyle{definition}
\newtheorem{definition}{Definition}

\begin{document} 
\begin{enumerate}
\item The typing relation has the form $\Gamma \vdash e : \tau$, which can be read as ``term $e$ has type $\tau$ in the typing context $\Gamma$''; $\Gamma$ is the set of assumptions on the types of the free variables in term $e$.
Hence, $\Gamma : \textrm{Term} \rightarrow \textrm{Type}$.
\item The function $\mathcal{L} : \textrm{Label} \rightarrow \mathbb{L}$ maps labels to elements of latice $\mathbb{L}$, i.e., $\mathcal{L}\llbracket l\rrbracket \in \mathbb{L}\cup\{\bot,\top\}$.
Furthermore, $\mathcal{L}$ is homomorphically defined over label operations, so 
$\mathcal{L}\llbracket l_1 \lub\ l_2\rrbracket = \mathcal{L}\llbracket l_1 \rrbracket \lub \mathcal{L} \llbracket l_2\rrbracket$, and similarly $\mathcal{L}\llbracket l_1 \glb\ l_2\rrbracket = \mathcal{L}\llbracket l_1 \rrbracket \glb \mathcal{L} \llbracket l_2\rrbracket$.
Note that the label kind and lattice may be arbitrary defined as long as $\mathcal{L}$ is bijective.
\item The evaluation contexts $E$ are terms with a hole; where $E[e]$ is a term with the hole being replaced by $e$.
      It is important to note that, for a unique $E$,
      \begin{equation*}
      \inferrule{e\longrightarrow e^\prime}{E[e]\longrightarrow E[e^\prime]}
      \end{equation*}
\item We use the notion of an environment $\store$ that maps \lbl{} to the current label, and \clr{} to the current clearance as to keep track of and enforce information flow control.
The current label is the highest label of all the variables that we can name in the environment; for example, if we current label is high, then we can name variables that were labeled high, hose label was removed.
The function \withLblClr{} is used to initialize the environment, which may be updated by functions such as \open{}.
Note that, in practice, this may be implemented using a state transformer monad that threads the label and clearance through the computations.
\item We define a wrapper monad, \LIOp{}, that is simply used to prevent the escaping of wrapped values (which could violate information flow).
\item The evaluation relation consisting that may have side-effects in the environment is
      \begin{equation*}
      \inferrule{e\longrightarrow e^\prime}{\langle \store, e\rangle \longrightarrow \langle \store^\prime, e^\prime\rangle }
      \end{equation*}
      which may be read as ``term $e$ in environment $\store$ evaluates to $e^\prime$ in environment $\store^\prime$''.
\item We say that a term is ``stuck'' (at run-time) if it violates information flow control.
\end{enumerate}

\begin{language}
\begin{align*}
\textrm{Lattice:}             && \mathbb{L} &= (L, \sqsubseteq, \lub, \glb, \bot, \top)                 \\
\\
\textrm{Label:}               && l, c &\\
\\
\textrm{Value:}               && v    &\Coloneqq   x                    \\ % variable
                              &&      &\ |\  \lambda x.e                \\ % abstraction
                              &&      &\ |\  (e, e)                     \\ % tuple
                              &&      &\ |\  \Lv\ e\ e                  \\ % value of type Lvalue
                              &&      &\ |\  \lioValp{e}                \\ % value of type LIO'
                              &&      &\ |\  \true                      \\ % value of type Bool
                              &&      &\ |\  \false                     \\ % value of type Bool
                              &&      &\ |\  l                          \\ % label
                              &&      &\ |\  \fix\ e                    \\ % recursion
\\
\textrm{Term:}                && e    &\Coloneqq  v                     \\ % values
                              &&      &\ |\  e\ e                       \\ % application
                              &&      &\ |\  \ifel{e}{e}{e}             \\ % recursion
                              &&      &\ |\  \letbind{x}{e}{e}          \\ % let-bindings
                              &&      &\ |\  \pi_i\ e                   \\ % \pi_1 = fst, \pi_2 = snd
                              &&      &\ |\  \return\ e                 \\ % return
                              &&      &\ |\  e\ \bind\ e                \\ % bind two expressions
                              &&      &\ |\  e\ \seq\ e                 \\ % sequence two expressions
                              &&      &\ |\  \withLblClr\ e\ e          \\ % withLblClr
%                              &&      &\ |\  \langle \store, \ e\rangle   \\ % LIO value
                              &&      &\ |\  \seal\ e\ e                \\ % seal
                              &&      &\ |\  \open\ e                   \\ % open
                              &&      &\ |\  \returnLIOp\ e\             \\ % returnLIOp
                              &&      &\ |\  e\ \bindLIOp\ e             \\ % bind two expressions
%                              &&      &\ |\  \evalLIO\ e\ e             \\ % evalLIO
                              &&      &\ |\  e\ \lub\ e                 \\ % lub
                              &&      &\ |\  e\ \glb\ e                 \\ % glb
\\
\textrm{Type:}                && \tau &\Coloneqq  \tau\rightarrow\tau   \\ % function
                              &&      &\ |\  (\tau,\tau)                \\ % tuple
                              &&      &\ |\  \Bool                      \\ % bool
                              &&      &\ |\  \ell                       \\ % Label
                              &&      &\ |\  \Lvalue\ \ell\ e           \\ % Lvalue
%                              &&      &\ |\  \LIO\ \ell\ e              \\ % LIO
                              &&      &\ |\  \LIOp\ \ell\ e             \\ % LIO'
%                              &&      &\ |\  \IO                        \\ % IO
\\
\textrm{Environment:}         && \store & : \{\lbl,\clr\} \rightarrow \textrm{Label}   \\
\\
\textrm{Program:}             && p    &\Coloneqq  (\letbind{x}{e}{})^*(\withLblClr\ e\ e)
\end{align*}
\caption{Haskell embeded information flow control language. $\Lv\ e\ e$ is the runtime representation of a labeled value and it does not appear in the source. Similarly $\lioValp{e}$ is the runtime representation of a \LIOp{} value.}
\label{language:lvalue}
\end{language}

\begin{typerules}
\begin{align}
\inferrule{\Gamma(x)=\tau} 
     {\Gamma \vdash x : \tau}\tag{T-Var}
\\
\inferrule{\Gamma[x \mapsto \tau_1] \vdash e : \tau_2} 
     {\Gamma \vdash \lambda x.e : \tau_1 \rightarrow \tau_2}\tag{T-Abs}
\\
\inferrule{\Gamma \vdash e_1 : \tau_1 \\ \Gamma \vdash e_2 : \tau_2 }
     {\Gamma \vdash (e_1,e_2) : (\tau_1, \tau_2)}\tag{T-Tup}
\\
\inferrule{\Gamma \vdash e_1 : \ell \\ \Gamma \vdash e_2 : \tau}
     {\Gamma \vdash \Lv\ e_1\ e_2 : \Lvalue\ \ell\ \tau}\tag{T-Lv}
\\
\inferrule{}{\vdash \true : \Bool}\tag{T-True}
\\
\inferrule{}{\vdash \false : \Bool}\tag{T-False}
\\
\inferrule{}{\vdash l : \ell}\tag{T-Label}
\\
\inferrule{\Gamma \vdash e : \tau \rightarrow \tau}
     {\Gamma \vdash \fix\ e : \tau}\tag{T-Fix}
\\
\inferrule{\Gamma \vdash e_1 : \tau_1 \rightarrow \tau_2 \\ \Gamma \vdash e_2 : \tau_1}
     {\Gamma \vdash e_1\ e_2 : \tau_2}\tag{T-App}
\\
\inferrule{\Gamma \vdash e_1 : \Bool \\ \Gamma \vdash e_2 : \tau \\ \Gamma \vdash e_3 : \tau}
     {\Gamma \vdash \ifel{e_1}{e_2}{e_3} : \tau}\tag{T-IfEl}
\\
\inferrule{\Gamma \vdash e_1 : \tau_1 \\ \Gamma [x \mapsto \tau_1] \vdash e_2 : \tau_2}
     {\Gamma \vdash \letbind{x}{e_1}{e_2} : \tau_2}\tag{T-Let}
\\
\inferrule{\Gamma \vdash e : (\tau_1, \tau_2)}
     {\Gamma \vdash \pi_i\ e : \tau_i}
     {(i\in\{1,2\})}\tag{T-Proj}
\\
\inferrule{\Gamma[l_\bot \mapsto \ell] \vdash e : \tau}
     {\Gamma \vdash \return\ e : \Lvalue\ \ell\ \tau}\tag{T-Ret}
\\
\inferrule{\Gamma \vdash e_1 : \Lvalue\ \ell\ \tau_1 \\ \Gamma \vdash e_2 : \tau_1 \rightarrow \Lvalue\ \ell\ \tau_2}
     {\Gamma \vdash e_1\ \bind\ e_2 : \Lvalue\ \ell\ \tau_2}\tag{T-Bind}
\\
\inferrule{\Gamma \vdash e_1 : \Lvalue\ \ell\ \tau_1 \\ \Gamma \vdash e_2 : \Lvalue\ \ell\ \tau_2}
     {\Gamma \vdash e_1\ \seq\ e_2 : \Lvalue\ \ell\ \tau_2}\tag{T-Seq}
\\
\inferrule{\Gamma \vdash e_1 : \ell\\ \Gamma \vdash e_2 : \ell}
     {\Gamma \vdash e_1\ \lub\ e_2 : \ell}\tag{T-Join}
\\
\inferrule{\Gamma \vdash e_1 : \ell\\ \Gamma \vdash e_2 : \ell}
     {\Gamma \vdash e_1\ \glb\ e_2 : \ell}\tag{T-Meet}
\end{align}
\caption{Type rules where the monadic bind and return are solely given for \Lvalue{} types.}
\end{typerules}

\begin{typerules}
\begin{align}
\inferrule{\Gamma \vdash e : \tau}
     {\Gamma \vdash \lioValp{e} : \LIOp\ \tau}\tag{T-LIO'-Val}
\\
\inferrule{\Gamma \vdash e_1 : (\ell,\ell) \\ \Gamma \vdash e_2 : \tau}
     {\Gamma \vdash \withLblClr\ e_1\ e_2: \tau}\tag{T-WithLblClr}
%\\
%\inferrule{\Gamma \vdash e : \tau}
%     {\Gamma \vdash \langle \store, e \rangle: \LIO\ \ell\ \tau}\tag{T-LIO-Val}
\\
\inferrule{\Gamma \vdash e_1 : \tau \\ \Gamma \vdash e_2 : \ell}
     {\Gamma \vdash \seal\ e_1\ e_2: \LIOp\ (\Lvalue\ \ell\ \tau)}\tag{T-Seal}
\\
\inferrule{\Gamma \vdash e : \Lvalue\ \ell\ \tau}
     {\Gamma \vdash \open\ e : \LIOp\ \tau}\tag{T-Open}
\\
\inferrule{\Gamma \vdash e : \tau}
     {\Gamma \vdash \returnLIOp\ e  : \LIOp\ \tau}\tag{T-LIO'-Ret}
\\
\inferrule{\Gamma \vdash e_1 : \LIOp\ \tau_1 \\ \Gamma \vdash e_2 : \tau_1 \rightarrow \LIOp\ \tau_2}
     {\Gamma \vdash e_1\ \bindLIOp\ e_2 : \LIOp\ \tau_2}\tag{T-LIO'-Bind}
\end{align}
\caption{Type rules where the monadic bind and return are solely given for \Lvalue{} types.}
\caption{Type rules for terms with side-effects.}
\end{typerules}


\begin{sos}
\begin{align*}
&&E&   ::=  [\cdot]                    
       \ |\  E\ e                       
       \ |\  (E, e)                     
       \ |\  (v, E)                     
       \ |\  \ifel{E}{e}{e}
       \ |\  \letbind{x}{E}{e}
       \ |\  \pi_i\ E                     
       \\
&&&    \ |\  \return\ E                 
       \ |\  E\ \diamond\ e                
       \ |\  v\ \diamond\ E, \textrm{where }\diamond = \{\bind, \seq, \lub, \glb\}
       \\
\\                                                                                                    
&&&E[(\lambda x.e_1)\ e_2]                         \longrightarrow E[[e_2/x]e_1]          \tag{E-App}    \\
&&&E[\fix\ e]                                      \longrightarrow E[e\ \fix\ e]          \tag{E-Fix}    \\
&&&E[\ifel{\true}{e_1}{e_2}]                       \longrightarrow E[e_1]                 \tag{E-IfTrue} \\
&&&E[\ifel{\false}{e_1}{e_2}]                      \longrightarrow E[e_2]                 \tag{E-IfFalse}\\
&&&\inferrule{e_1 \longrightarrow {e_1}^\prime}
   {E[\letbind{x}{e_1}{e_2}]                       \longrightarrow E[\letbind{x}{{e_1}^\prime}{e_2}]}         \tag{E-Let}    \\
&&&E[\letbind{x}{v}{e}]                            \longrightarrow E[[v/x]e]                                  \tag{E-LetVal} \\
&&&E[\pi_i\ (e_1,e_2)]                             \longrightarrow E[e_i]                 \tag{E-Proj}   \\
&&&E[\return\ e]                                   \longrightarrow E[\Lv\ l_\bot\ e] \tag{E-Ret}    \\
&&&\inferrule{e_2 \ne \Lv\ e_l\ e_2^\prime}
      {E[\Lv\ l_1\ e_1\ \bind\ \lambda x.e_2]      \longrightarrow E[[e_1/x]e_2\ \bind\ \lambda x.\Lv\ l_1\ x]}\tag{E-Bind} \\
&&&E[\Lv\ l_1\ e_1\ \bind\ \lambda x.\Lv\ l_2\ e_2] \longrightarrow E[\Lv\ (l_1\lub l_2)\ [e_1/x]e_2]\tag{E-Runit}\\
&&&E[\Lv\ l_1\ e_1\ \seq\ e_2]                     \longrightarrow E[e_2\ \bind\ \lambda x.\return\ x]\tag{E-Seq} \\
&&&\inferrule{\mathcal{L}\llbracket l_3\rrbracket = \mathcal{L}\llbracket l_1 \lub l_2\rrbracket}
            {E[l_1\ \lub\ l_2] \longrightarrow E[l_3]} \tag{E-Join}\\
&&&\inferrule{\mathcal{L}\llbracket l_3\rrbracket = \mathcal{L}\llbracket l_1 \glb l_2\rrbracket}
           {E[l_1\ \glb\ l_2] \longrightarrow E[l_3]} \tag{E-Meet}
\end{align*}
\caption{Semantics for pure terms.}
\end{sos}

\begin{sos}
\begin{align*}
&&E&   ::=  \cdots
       \ |\  \seal\ E\ l                
       \ |\  \open\ E                 
       \ |\  \returnLIOp\ E
       \ |\  E\ \bindLIOp\ e
       \ |\  v\ \bindLIOp\ E
%       \ |\  \langle \store, E \rangle
       \ |\  \lioValp{E}
       \\
&&&
\inferrule{\store(\lbl)=l \\ \store(\clr)=c}
{\langle \emptyset, \withLblClr\ (l, c)\ e \rangle \longrightarrow \langle \store, e\rangle} \tag{E-WithLblClr}\\
&&&\inferrule{\store(\lbl) \sqsubseteq l_1 \sqsubseteq \store(\clr)}
      {\langle \store, E[\seal\ e\ l_1]\rangle \longrightarrow \langle \store, E[\lioValp{\Lv\ l_1\ e}]\rangle} \tag{E-LIO-Seal}  \\
&&&\inferrule{l^\prime = \store(\lbl) \lub l_1 \\ l^\prime \sqsubseteq \store(\clr) \\ \store^\prime = \store[\lbl \mapsto l^\prime]}
      {\langle \store, E[\open\ (\Lv\ l_1\ e_1)]\rangle \longrightarrow \langle \store^\prime, E[\lioValp{e_1}]\rangle} \tag{E-LIO-Open} \\
&&&E[\returnLIOp\ e] \longrightarrow E[\lioValp{e}] \tag{E-LIO'-Ret}\\
&&&E[\lioValp{e_1}\ \bindLIOp\ \lambda x. e_2] \longrightarrow E[[e_1/x]e_2] \tag{E-LIO'-Bind}\\
&&&E[\lioValp{e_1}\ \bindLIOp\ \lambda x. \returnLIOp\ x] \longrightarrow E[\lioValp{e_1}] \tag{E-LIO'-Runit}
\end{align*}
\caption{Semantics for terms with side effects; \texttt{Lref} case}
\end{sos}

\pagebreak

\subsection{Example} 
For the following examples we assume the following lattice elements: $\{\lL, \lH\}$ with the partial order $\bot \sqsubseteq \lL \sqsubseteq \lH \sqsubseteq \top$, and $\cdot \lub \lH = \lH$ and $\cdot \glb \lL = \lL$.
For simplicity, we refer to \lL{} as the ``public label'' and \lH{} as the ``secret label''.
Additionally, we define $l_\bot = \lL$ and $l_\top = \lH$.

Furthermore we assume the language is extended to support integer types and integer operations, e.g., addition.

\subsubsection{Example with no side-effects.} 
Let us consider a simple example, working only on pure terms. In this example we are given two labeled values, one with a public label \lL{} and another with a secret label \lH. Adding the two we expect the resulting value to be a labeled value with the secret label the secret label.

\begin{align*}
&                     && \Lv\ \lL\ 1\ \bind\ \lambda x.\
                         \Lv\ \lH\ 2\ \bind\ \lambda y.\
                         \return\ (x + y) \\
&\tref{E-Bind}:        & \longrightarrow &
                         \Lv\ \lH\ 2\ \bind\ \lambda y.
                         \return\ (1 + y)\
                         \bind\ \lambda x.\Lv\ \lL\ x\\
&\tref{E-Bind}:        & \longrightarrow &
                         \return\ (1 + 2)\
                         \bind\ \lambda x.\Lv\ \lL\ x
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-Ret}          & \longrightarrow &
                         \Lv\ l_\bot\ (1 + 2)\ 
                         \bind\ \lambda x.\Lv\ \lL\ x
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-Runit}:       & \longrightarrow &
                         \Lv\ (l_\bot\lub\lL)\ (1 + 2)\ 
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-Runit}:       & \longrightarrow &
                         \Lv\ (l_\bot\lub\lL\lub\lH)\ (1 + 2)\\
&\tref{E-Join}:        & \longrightarrow &
                         \Lv\ \lH\ (1 + 2)\\
&                      & \longrightarrow &
                        \Lv\ \lH\ 3
\end{align*}

\subsubsection{Example with side-effects.} 
Let us consider a more complex example, a full program, that has type checks and does not violate the information flow constraints.
For simplicity, we do not expand $f$.
\begin{align*}
&                     && {\tt let}\ f\ =\lambda x_l. \lambda y_l. x_l\ \bind\ \lambda x.
                                                  y_l\ \bind\ \lambda y.
                                                  \return\ (x + y)\\
&                     && {\tt in}\ \withLblClr (\lL, \lH)\ (\
                                \seal\ 1\ \lL\ \bindLIOp\ \lambda x.  
                                \seal\ 2\ \lH\ \bindLIOp\ \lambda y. 
                                \open\ (f\ x\ y)\ )\\
&\tref{E-LetVal}      & \longrightarrow & \withLblClr (\lL, \lH)\ (\
                                          \seal\ 1\ \lL\ \bindLIOp\ \lambda x.  
                                          \seal\ 2\ \lH\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ x\ y)\ )\\
&\tref{E-WithLblClr}  & \longrightarrow & \langle \store=\{(\lbl,\lL),(\clr,\lH)\},
                                          \seal\ 1\ \lL\ \bindLIOp\ \lambda x.  
                                          \seal\ 2\ \lH\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ x\ y) \rangle\\
&\tref{E-LIO-Seal}    & \longrightarrow & \langle \store=\{(\lbl,\lL),(\clr,\lH)\}, 
                                          \lioValp{\Lv\ \lL\ 1}\ \bindLIOp\ \lambda x.  
                                          \seal\ 2\ \lH\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ x\ y) \rangle\\
&\tref{E-LIO'-Bind}   & \longrightarrow & \langle \store=\{(\lbl,\lL),(\clr,\lH)\}, 
                                          \seal\ 2\ \lH\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ (\Lv\ \lL\ 1) \ y) \rangle\\
&\tref{E-LIO-Seal}    & \longrightarrow & \langle \store=\{(\lbl,\lL),(\clr,\lH)\}, 
                                          \lioValp{\Lv\ \lH\ 2}\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ (\Lv\ \lL\ 1) \ y) \rangle\\
&\tref{E-LIO'-Bind}   & \longrightarrow & \langle \store=\{(\lbl,\lL),(\clr,\lH)\}, 
                                          \open\ (f\ (\Lv\ \lL\ 1)\ (\Lv\ \lH\ 2)) \rangle\\
&\textrm{Evaluate $f$}& \longrightarrow^* & \langle \store=\{(\lbl,\lL),(\clr,\lH)\}, 
                                          \open\ (\Lv\ \lH\ 3) \rangle\\
&\tref{E-LIO-Open}    & \longrightarrow & \langle \store=\{(\lbl,\lH),(\clr,\lH)\}, 
                                          \lioValp{3} \rangle\\
\end{align*}
\subsubsection{Example with side-effects that violates information flow.} 
As above, we consider a full program, but in this case one that would violates information flow (flow from a secret value to a public value).
\begin{align*}
&                     && \withLblClr (\lL, \lH)\ (\
                         \seal\ 1\ \lH\ \bindLIOp\ \lambda x.  
                         \open\ x\ \bindLIOp\ \lambda y. 
                         \seal\ y\ \lL)\\
&\tref{E-WithLblClr}  & \longrightarrow & \langle \store=\{(\lbl,\lL),(\clr,\lH)\},
                                          \seal\ 1\ \lH\ \bindLIOp\ \lambda x.  
                                          \open\ x\ \bindLIOp\ \lambda y. 
                                          \seal\ y\ \lL)\rangle\\
&\tref{E-LIO-Seal}    & \longrightarrow & \langle \store=\{(\lbl,\lL),(\clr,\lH)\},
                                          \lioValp{\Lv\ \lH\ 1}\ \bindLIOp\ \lambda x.  
                                          \open\ x\ \bindLIOp\ \lambda y. 
                                          \seal\ y\ \lL\rangle\\
&\tref{E-LIO'-Bind}   & \longrightarrow & \langle \store=\{(\lbl,\lL),(\clr,\lH)\},
                                          \open\ (\Lv\ \lH\ 1)\ \bindLIOp\ \lambda y. 
                                          \seal\ y\ \lL\rangle\\
&\tref{E-LIO-Open}    & \longrightarrow & \langle \store=\{(\lbl,\lH),(\clr,\lH)\},
                                          \lioValp{1}\ \bindLIOp\ \lambda y. 
                                          \seal\ y\ \lL\rangle\\
&\tref{E-LIO'-Bind}   & \longrightarrow & \langle \store=\{(\lbl,\lH),(\clr,\lH)\},
                                          \seal\ 1\ \lL\rangle\\
&\tref{E-LIO-Seal}    & \texttt{STUCK: }& \textrm{Premise for rule is not satisfied: $\store(\lbl)=\lH \not\sqsubseteq \lL$.}
\end{align*}








\pagebreak

\subsection{Well-behaved terms}
We define a function ${\mathcal{W}\llbracket \rrbracket} : \textrm{Environment}\times\textrm{Term} \rightarrow \{\tT, \tF\}$, where $\tT{}$ denotes true, and $\tF{}$ denotes false.

\begin{align*}
\well{\store}{x} &= \tT\\
\well{\store}{\lambda x. e} &= \well{\store}{e}\\
\well{\store}{\lioValp{e}} &= \well{\store}{e}\\
\well{\store}{\true} &= \tT\\
\well{\store}{\false} &= \tT\\
\well{\store}{l} &= \tT\\
\well{\store}{\fix\ e} &= \well{\store}{e}\\
\well{\store}{\Lv\ l\ e} &= \well{\store}{e}\\
\well{\store}{e_1\ e_2} &= \well{\store}{e_1} \land \well{\store}{e_2}\\
\well{\store}{\ifel{\true}{e_1}{e_2}} &= \well{\store}{e_1}\\
\well{\store}{\ifel{\false}{e_1}{e_2}} &= \well{\store}{e_2}\\
&\vdots\\
\well{\store}{\seal\ e\ l_1}          &= (\store(\lbl) \sqsubseteq l_1 \sqsubseteq \store(\clr)) \land\ \well{\store}{e}\\
\well{\store}{\open\ (\Lv\ l_1\ e_1)} &= (\store^\prime(\lbl) \sqsubseteq \store(\clr)) \land \well{\store^\prime}{e},\\
                                      &\textrm{where } \store^\prime=\store[\lbl\mapsto l^\prime], \textrm{and } l^\prime = \store(\lbl)\lub l_1
\end{align*}

The remaining terms are similarly defined. We say that a term $e$ is well-behaved (at this point in the execution) in environment $\store$ if $\well{\store}{e}=\tT$.


\subsection{Language properties}

\begin{lemma}[Preservation of pure terms]
If $\vdash e : \tau$ and $e \longrightarrow e^\prime$ then $\vdash e^\prime : \tau$.
\end{lemma}
In other words, a well-typed term taking an evaluation step results in a term that is also well-typed.

\begin{lemma}[Type and information flow preservation]
If $\vdash e : \tau$ and $\langle \store, e\rangle \longrightarrow \langle \store^\prime, e^\prime \rangle$ then $\vdash e^\prime : \tau$.
\end{lemma}
A well-typed and well-behaved term taking an evaluation step results in a term that is also well-typed.

\begin{lemma}[Progress of pure terms]
If $\vdash e : \tau$ and $e$ does not depend on an environment (i.e., $e$ does not contain \seal{} or \open{}), then $e \longrightarrow v$, or there exists $e^\prime$ such that $e \longrightarrow e^\prime$.
\end{lemma}
In other words, a closed and well-typed pure term is not stuck.

\begin{lemma}[Progress of well-typed and well-behaved terms]
Given environment $\store$, if $\vdash e : \tau$ and $\well{\store}{e}$ then $\langle \store, e \rangle \longrightarrow \langle \store^\prime, v\rangle$, or there exists $e^\prime$ such that $\langle \store, e \rangle \longrightarrow \langle \store^\second, e^\prime\rangle$.
\end{lemma}
This lemma states that a well-typed and well-behaved term is either a value or is not stuck. A well-typed term, however, may get``stuck'' if it not well-behaved, i.e., violates information flow.

%\begin{theorem}[Type safety of pure terms]
%If $\vdash e : \tau$ and $e \longrightarrow e^\prime$, then $e^\prime$ is not stuck.
%\end{theorem}

\begin{definition}[Low-equivalence]
Two values, each consisting of a pair of values with labels ${l}, {l}'$ such that $ {l}' \not\sqsubseteq{l}$, are equivalent according to the equivalence relation $=_L$  if they agree on the low values. Specifically, 
\begin{equation*}
\inferrule{(\Gamma \vdash e_j : (\Lvalue\ {l}'\ \tau'_i, \Lvalue\ {l}\ \tau_i))_{j=1,2} \\ (e_j\longrightarrow^* v_j)_{j=1,2}\\ \pi_2\ v_1 = \pi_2\ v_2\\ l \sqsubseteq L\\ L\not\sqsubseteq l}
{e_1 =_L e_2}
\end{equation*}
\end{definition}

For example, $(\Lv\ \lH\ 8,\Lv\ \lL\ 2) =_\lL (\Lv\ \lH\ 9,\Lv\ \lL\ 2)$, but 
$(\Lv\ \lH\ 8,\Lv\ \lL\ 2) \not =_{\lL} (\Lv\ \lH\ 8,\Lv\ \lL\ 3)$.
Similarly, if we extend the lattice with element $\lM : \lL\sqsubseteq \lM \sqsubseteq \lH$, 
$(\Lv\ \lH\ 8,\Lv\ \lL\ 2) =_\lL (\Lv\ \lM\ 9,\Lv\ \lL\ 2)$.

The low-equivalence expresses the observing power of an attacker; an attacker may observe any values labeled with at most $L$.

\begin{theorem}[Non-interference]
Given labels ${l}, {l}'$ such that $ {l}' \not\sqsubseteq{l}$,
a computation $e$ such that $\Gamma \vdash e : (\Lvalue\ {l}'\ \tau'_i, \Lvalue\ {l}\ \tau_i) \rightarrow (\Lvalue\ {l}'\ \tau'_o, \Lvalue\ {l}\ \tau_o)$ in environment $\store$, such that $\store(\lbl)\sqsubseteq l_i \sqsubseteq \store(\clr)$ for $l_i = \{l,l'\}$,
and an attacker $\Adv$ with clearance $c_\Adv$ such that ${l} \sqsubseteq c_\Adv$ and ${l}' \not\sqsubseteq c_\Adv$,
\begin{align*}
\forall e_1 e_2.&(\Gamma \vdash e_j : (\Lvalue\ \ell'\ \tau'_i,\Lvalue\ \ell\ \tau_i))_{j=1,2}\\
&\land e_1 =_L e_2\\ 
&\land \langle \store, e\ e_1\rangle \longrightarrow^* \langle \store^\prime, v_1\rangle\\
&\land \langle \store, e\ e_2\rangle \longrightarrow^* \langle \store^\prime, v_2\rangle\\
&\Rightarrow v_1 =_{c_\Adv} v_2.
\end{align*}
\end{theorem}

In other words, given two inputs, each consisting of a pair of values with a public and secret labels, the result of the well-behaved computation as observed by the attacker (at label level up to $c_\Adv$) is indistinguishable.





















\end{document} 
The parametrized evaluation relations directly translate to non-parametrized evalution relations in a state transformer monad (with the underlying monad being {\tt IO} and the state being the label $l$ and clearance $c$); this monad is the Labeled IO monad---{\tt LIO}.
More specifically, ${\tt LIO} :: (\ell,\ell)\rightarrow {\tt IO}\ (\tau,(\ell,\ell))$, which can be read as ``starting from an initial state haviung label and clearance $(l,c)::(\ell,\ell)$ an {\tt LIO} action is executed in the {\tt IO} monad and produces a value of type $\tau$ and a new state $(l',c')$''.

Consider the semantics of \seal{} with non-paremetric evaluation context:
\begin{equation*}
\inferrule{l \sqsubseteq l_1 \sqsubseteq c} {E[\seal\ e\ l_1] \evalrel{l}{c}{l}{c} E[\Lv\ l\ e]}
\end{equation*}
can be rewritten to
\begin{align*}
E[\seal\ e\ l_1] \longrightarrow E[&\getS\ \bindLIOp\ \lambda(l,c).\\
                                   &{\tt if}\ { l \sqsubseteq l_1 }\\
                                   &{\tt then}\ \ifel{l_1 \sqsubseteq c}{\returnLIOp\ (\Lv\ l\ e)}{\texttt{lerror}\ l\ \textrm{``$\ldots$''}}\\
                                   &{\tt else}\ {\texttt{lerror}\ l\ \textrm{``$\ldots$''}}]
\end{align*}
where bind and return are lift to and sequence {\tt LIO} actions and not \Lvalue{}s. 
Additionally the error function {\tt lerror} returns a labeled error in {\tt IO}.
Finally, \getS{} and \putS{} are functions of the MonadState type class (of which {\tt LIO} is an instance).

Similarly,
\begin{equation*}
\inferrule{l^\prime = l \lub l_1 \\ l^\prime \sqsubseteq c}{E[\open\ \Lv\ l_1\ e_1] \evalrel{l}{c}{l^\prime}{c} E[e_1]}
\end{equation*}
can be rewritten to:
\begin{align*}
E[\open\ \Lv\ l_1\ e_1] \longrightarrow
E[&\getS\ \bindLIOp\ \lambda(l,c).\\
  &{\tt let}\ {l^\prime}={l\lub l_1}\\
  &{\tt in }\ {\tt if}\ {l^\prime \sqsubseteq c}\\
  &\quad\quad {\tt then}\ {\putS\ (l^\prime,c)\ \seqLIO\ \returnLIOp\ e_1}\\
  &\quad\quad {\tt else}\ {\texttt{lerror}\ l\ \textrm{``$\ldots$''}}]
%  {\ifel{l^\prime \sqsubseteq c}{(\putS\ (l^\prime,c)\ \seqLIO\ \returnLIOp\ e_1)}{(\texttt{lerror}\ l\ \textrm{``$\ldots$''})}}]
%\letbind{l^\prime}{l\lub l_1}{\ifel{l^\prime \sqsubseteq c}{(\putS\ (l^\prime,c)\ \seqLIO\ \returnLIOp\ e_1)}{(\texttt{lerror}\ l\ \textrm{``$\ldots$''})}}]
\end{align*}
%\begin{equation*}
%E[\open\ \Lv\ l_1\ e_1] \longrightarrow E[\getS\ \bindLIOp\ \lambda(l,c).\letbind{l^\prime}{l\lub l_1}{
%\ifel{l^\prime \sqsubseteq c}{(\putS\ (l^\prime,c)\ \seqLIO\ \returnLIOp\ e_1)}{(\texttt{lerror}\ l\ \textrm{``$\ldots$''})}}]
%\end{equation*}


We note that any program using the \seal{}, \open{} functions must be executed as an {\tt LIO} action, using to set the initial state.
\pagebreak

\begin{sos}
\begin{align*}
&&&E[\return\ e] \evalrel{l}{c}{l}{c} E[\Lv\ l\ e] \tag{E-Ret}  \\
&&&\inferrule{{l_1}^\prime=l\lub l_1 \\ {l_1}^\prime \sqsubseteq c}
      {E[\return^\prime\ e\ l_1] \evalrel{l}{c}{l}{c} E[\Lv\ l_1\ e]} \tag{E-Ret$^\prime$}  \\
&&&\inferrule{E[[e_1/x]e_2] \transevalrel{l}{c}{l^\prime}{c} E[\Lv\ l_2\ {e_2}^\prime]\\ {l_2}^\prime=l_1\lub l_2 \lub l^\prime \\ {l_2}^\prime\sqsubseteq c}
      {E[\Lv\ l_1\ e_1\ \bind\ \lambda x.e_2]   \evalrel{l}{c}{l^\prime}{c} E[[e_1/x]e_2\ \bind\ \lambda x.\return^\prime\ x\ {l_2}^\prime]}\tag{E-Bind} \\
&&&\inferrule{{l_1}^\prime = l_1\lub l_2 \\ {l_1}^\prime \sqsubseteq c}{E[\Lv\ l_1\ e_1\ \bind\ \lambda x.\return^\prime\ x\ l_2] \evalrel{l}{c}{l}{c} E[\Lv\ l_1^\prime\ e_1]}\tag{E-Runit}\\
&&&\inferrule{{l_1}^\prime=l\lub l_1 \\ {l_1}^\prime \sqsubseteq c}
      {E[\seal\ e\ l_1] \evalrel{l}{c}{l}{c} E[\Lv\ l_1\ e]} \tag{E-Seal}  \\
&&&\inferrule{l^\prime = l \lub l_1 \\ l^\prime \sqsubseteq c}
      {E[\open\ \Lv\ l_1\ e_1] \evalrel{l}{c}{l^\prime}{c} E[e_1]} \tag{E-Open} 
\end{align*}
\caption{Semantics for terms with side effects; \texttt{Lvalue} case}
\end{sos}
\begin{lemma}[Type preservation under substitution]
If $\Gamma[x \mapsto \tau] \vdash e : \tau'$ and $\Gamma \vdash v : \tau$ then $\Gamma \vdash [v/x]e : \tau'$.
\end{lemma}
