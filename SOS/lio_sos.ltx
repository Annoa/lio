\documentclass[10pt]{article} 
\usepackage[margin=1in]{geometry} 
\usepackage{float}
\usepackage{amsmath,amssymb,amsfonts,amsthm,stmaryrd,txfonts, mathabx}
\DeclareMathOperator{\dom}{dom}
\usepackage{float}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage[usenames,dvipsnames]{color}
\newcommand{\Red}[1]{{\color{red} #1}}
\pagestyle{empty}

\date{\today}
 
\newcommand{\fix}{\texttt{fix}}
\newcommand{\lvalue}{\texttt{lvalue}}
\newcommand{\return}{\texttt{return}}
\newcommand{\bind}{\texttt{>>=}}
\newcommand{\seq}{\texttt{>>}}
\newcommand{\Lvalue}{\texttt{Lvalue}}
\newcommand{\Bool}{\texttt{Bool}}
\newcommand{\true}{\texttt{true}}
\newcommand{\false}{\texttt{false}}
\newcommand{\ifel}[3]{\texttt{if}\ #1\ \texttt{then}\ #2\ \texttt{else}\ #3}
\newcommand{\letbind}[3]{\texttt{let}\ #1=#2\ \texttt{in}\ #3}
\newcommand{\Lv}{\texttt{Lv}}
\newcommand{\flows}{\sqsubseteq^\ell}
\newcommand{\lub}{\sqcup^\ell}
\newcommand{\glb}{\sqcap^\ell}
\newcommand{\lpure}{l_\bot^\ell}
\newcommand{\labelOf}[1]{\mathcal{L} \llbracket #1 \rrbracket}
\newcommand{\lL}{\texttt{L}}
\newcommand{\lM}{\texttt{M}}
\newcommand{\lH}{\texttt{H}}
\newcommand{\lE}{\texttt{E}}
\newcommand{\Adv}{\mathcal{A}}
\newcommand{\seal}{\texttt{seal}}
\newcommand{\open}{\texttt{open}}
\newcommand{\close}{\texttt{close}}
\newcommand{\nolabel}{\obslash}
\newcommand{\unit}{\texttt{()}}


\newcommand{\LIO}{\texttt{LIO}}
\newcommand{\LIOp}{\texttt{LIO$^\prime$}} %$^\prime\ell$}}
\newcommand{\IO}{\texttt{IO}}
\newcommand{\returnLIOp}{\texttt{return}^\texttt{\tiny LIO$^\prime$}}
\newcommand{\bindLIOp}{\texttt{>>=}^\texttt{\tiny LIO$^\prime$}}
\newcommand{\seqLIO}{\texttt{>>}^\texttt{\tiny LIO$^\prime$}}
\newcommand{\lioValp}[1]{(#1)^\texttt{\tiny LIO$^\prime$}}

\newcommand{\tref}[1]{\textrm{#1}}

\newcommand{\withLblClr}{\texttt{withLblClr}}
\newcommand{\env}{\Delta_\ell}
\newcommand{\lbl}{\texttt{lbl}}
\newcommand{\clr}{\texttt{clr}}

\newcommand{\well}[2]{\mathcal{W}\llbracket #1,  #2 \rrbracket}
\newcommand{\tT}{\mathbb{T}}
\newcommand{\tF}{\mathbb{F}}

\newcommand{\hole}{\bullet}
\newcommand{\erase}[2]{\varepsilon_{#1}(#2)}
\newcommand{\el}[1]{\erase{L}{#1}}

% --
\newcommand{\str}{\phi}
\newcommand{\Ref}[2]{\texttt{Ref}\ #1\ #2}
\newcommand{\newRef}[2]{\texttt{newRef}\ #1\ #2}
\newcommand{\readRef}[1]{\texttt{readRef}\ #1}
\newcommand{\writeRef}[2]{\texttt{writeRef}\ #1\ #2}

\floatstyle{ruled}
\newfloat{typerules}{htbp}{lop} \floatname{typerules}{Typing Rule}
\newfloat{sos}{htbp}{lop} \floatname{sos}{Operational Semantics}
\newfloat{language}{htbp}{lop} \floatname{language}{Language}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{proposition}{Proposition}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\theoremstyle{remark}
\newtheorem{proofidea}{Proof idea}

\begin{document} 
\begin{enumerate}
\item
The typing relation has the standard form $\Gamma \vdash e : \tau$, which
can be read as ``term $e$ has type $\tau$ in the typing context $\Gamma$'';
$\Gamma$ is the set of assumptions on the types of the free variables in term
$e$.
Hence, $\Gamma : \textrm{Term} \rightarrow \textrm{Type}$.

\item
The function $\mathcal{L} : \textrm{Label} \rightarrow \mathsf{L}$ maps
labels to elements of lattice $\mathbb{L}$, i.e.,
$\labelOf{l} \in \mathsf{L}\cup\{\bot,\top\}$.
We use the meta-variables $l$ to denote Label values of type $\ell$.

The label type ($\ell$) and lattice may be arbitrary defined as long as
$\mathcal{L}$ is bijective.
However, we require that every label kind provide a default label for pure
values, denoted by $\lpure$ such that 
$\labelOf{\lpure} \in \mathsf{L}\cup\{\bot,\top\}$, and binary operators
$\lub, \glb, \flows$.
We highlight that $\mathcal{L}$ is homomorphically defined over label operations
$op \in \{\lub, \glb, \flows\}$, so
$\labelOf{l_1\ op\ l_2} = \labelOf{l_1}\ op\ \labelOf{l_2}$.


We overload operator $\flows$ to allow for comparison of syntactic labels in
the premise of evaluation rules. For example, $l_1 \flows l_2$ can be 
is has the semantic meaning of $\labelOf{l_1} \flows \labelOf{l_2}$.

\item
The evaluation contexts $E$ are terms with a hole; where $E[e]$ is a term
with the hole being replaced by $e$.
It is important to note that, for a unique $E$,
\begin{equation*}
\inferrule{e\longrightarrow e^\prime}{E[e]\longrightarrow E[e^\prime]}
\end{equation*}

\item
We use the notion of an environment
$\env : \{\lbl, \clr\} \rightarrow \textrm{Label}$ that maps
the {\em current label}, \lbl{}, and {\em current clearance}, \clr{}, to a
label value.
The current label is effectively a ceiling over the labels of all data the
current computation may depend on, the current clearance specified an upper
bound on permissible values of the current label.
This suggests that all data within the computation is uniformly
labeled by the current label. We provide labeled values ($\Lv{}\ l\ v$) to allow
for values ($v$) to be protected by labels ($l$) other than the current label.


The function \withLblClr{} is used to initialize $\env{}$, which may be
updated with functions such as \open{}.
In the actual implementation, we use a state transformer monad to
``thread'' the current label and clearance over the computation.
Our semantics assume the ability to modify and query the environment, which
we do not model explicitly:
we can avoid this layer of implementation detail as it provides no
interesting properties. Hence, our semantics are akin to modular monadic
semantics.

\item
Side-effects of certain functions may modify the environment $\env$.
The evaluation relation that may have side-effects in the environment is
\begin{equation*}
\inferrule{e\longrightarrow e^\prime}
{\langle \env, e\rangle \longrightarrow \langle \env^\prime, e^\prime\rangle}
\end{equation*}
which may be read as ``term $e$ in environment $\env$ evaluates to
$e^\prime$ in environment $\env^\prime$''.


\item
We define a wrapper type, \LIOp{}, the constructor of which is used to
wrap/box values $v$ into $\lioValp{v}$. \LIOp{} is a monad, for which we 
limit the operations to return and bind.
\Red{Do we need to parametrize \LIOp{} with $\ell$?}

\item
We say that a term is {\em stuck} at run-time if it violates information
flow control.

\item
For the ongoing examples we assume the following lattice elements:
$\{\lL, \lH\}$ with partial order $\bot \flows \lL \flows \lH \flows \top$,
and $\cdot \lub \lH = \lH$ and $\cdot \glb \lL = \lL$.
Additionally, we let $\lpure = \lL$.
For simplicity, we refer to \lL{} as the ``public label'' and
\lH{} as the ``secret label''. We assume the language supports
integer types and integer operations, e.g., addition.
\end{enumerate}

\begin{language}
\begin{align*}
\textrm{Lattice:} && \mathbb{L}&= (\mathsf{L}, \flows, \lub, \glb, \bot, \top)\\
\\
\textrm{Label:}   && l  &\\
\\
\textrm{Store address:}   && a  &\\
\\
\textrm{Value:}   && v    &\Coloneqq   x                    % variable
                           \ |\  \lambda x.e                % abstraction
                           \ |\  (v, v)                     % tuple
                           \ |\  \Lv\ v\ v                  % val of type Lvalue
                           \ |\  \lioValp{v}                % value of type LIO'
                           \ |\  \true                      % value of type Bool
                           \ |\  \false                     % value of type Bool
                           \ |\  l                          % label
                           \ |\  a                          % address
                           \ |\  \unit                      % unit
                           \ |\  \fix\ e                 \\ % recursion
\\
\textrm{Term:}    && e    &\Coloneqq  x                     % values
                           \ |\  \lambda x.e                % abstraction
                           \ |\  (e, e)                     % tuple
                           \ |\  \Lv\ e\ e                  % val of type Lvalue
                           \ |\  \lioValp{e}                % value of type LIO'
                           \ |\  \true                      % value of type Bool
                           \ |\  \false                     % value of type Bool
                           \ |\  l                          % label
                           \ |\  a                          % address
                           \ |\  \unit                      % unit
                           \ |\  \fix\ e                 \\ % recursion
                  &&      &\ |\  e\ e                       % application
                           \ |\  \ifel{e}{e}{e}             % recursion
                           \ |\  \letbind{x}{e}{e}          % let-bindings
                           \ |\  \pi_i\ e                \\ % pi_1=fst,pi_2=snd
                  &&      &\ |\  \return\ e                 % return
                           \ |\  e\ \bind\ e             \\ % bind two exprs
                  &&      &\ |\  \withLblClr\ e\ e          % withLblClr
                           \ |\  \seal\ e\ e                % seal
                           \ |\  \open\ e                   % open
                           \ |\  \close\ e               \\ % close
                  &&      &\ |\  \returnLIOp\ e\            % returnLIOp
                           \ |\  e\ \bindLIOp\ e         \\ % bind two exprs
                  &&      &\ |\  \newRef{e}{e}              % new ref
                           \ |\  \writeRef{e}{e}            % write ref
                           \ |\  \readRef{e}             \\ % read ref
                  &&      &\ |\  e\ \lub\ e                 % lub
                           \ |\  e\ \glb\ e              \\ % glb
\\
\textrm{Type:}    && \tau &\Coloneqq  \tau\rightarrow\tau   % function
                           \ |\  (\tau,\tau)                % tuple
                           \ |\  \Lvalue\ \tau_1\ \tau_2    % Lvalue
                           \ |\  \LIOp\ \tau                % LIO'
                           \ |\  \Ref{\tau_1}{\tau_2}       % Ref
                           \ |\  \Bool                      % bool
                           \ |\  \ell                       % Label
                           \ |\  \unit                   \\ % unit
\\
\textrm{Program:} && p    &\Coloneqq  (\letbind{x}{e}{})^*(\withLblClr\ e\ e)\\
\\
\textrm{Environment:} && \env & : \{\lbl,\clr\} \rightarrow l\\
                      && \str & : a \rightarrow (l, e)
\end{align*}
\caption{Haskell embedded information flow control language. $\Lv\ e\ e$ is the
runtime representation of a labeled value and it does not appear in the source.
Similarly $\lioValp{e}$ is the runtime representation of a \LIOp{} value.}
\label{language:lvalue}
\end{language}

\begin{typerules}
\begin{align}
\inferrule{\Gamma;\Phi(x)=\tau} 
     {\Gamma;\Phi \vdash x : \tau}\tag{T-Var}
\\
\inferrule{\Gamma;\Phi[x \mapsto \tau_1] \vdash e : \tau_2} 
     {\Gamma;\Phi \vdash \lambda x.e : \tau_1 \rightarrow \tau_2}\tag{T-Abs}
\\
\inferrule{\Gamma;\Phi \vdash e_1 : \tau_1 \\ \Gamma;\Phi \vdash e_2 : \tau_2 }
     {\Gamma;\Phi \vdash (e_1,e_2) : (\tau_1, \tau_2)}\tag{T-Tup}
\\
\inferrule{\Gamma;\Phi \vdash e_1 : \ell \\ \Gamma;\Phi \vdash e_2 : \tau}
     {\Gamma;\Phi \vdash \Lv\ e_1\ e_2 : \Lvalue\ \ell\ \tau}\tag{T-Lv}
\\
\inferrule{}{\vdash \true : \Bool}\tag{T-True}
\\
\inferrule{}{\vdash \false : \Bool}\tag{T-False}
\\
\inferrule{}{\vdash l : \ell}\tag{T-Label}
\\
\inferrule{}{\vdash \unit : \unit}\tag{T-Unit}
\\
\inferrule{\Gamma;\Phi \vdash e : \tau \rightarrow \tau}
     {\Gamma;\Phi \vdash \fix\ e : \tau}\tag{T-Fix}
\\
\inferrule
{\Gamma;\Phi \vdash e_1 : \tau_1 \rightarrow \tau_2
\\ \Gamma;\Phi \vdash e_2 : \tau_1}
{\Gamma;\Phi \vdash e_1\ e_2 : \tau_2}\tag{T-App}
\\
\inferrule
{\Gamma;\Phi \vdash e_1 : \Bool \\ \Gamma;\Phi \vdash e_2 : \tau
                           \\ \Gamma;\Phi \vdash e_3 : \tau}
{\Gamma;\Phi \vdash \ifel{e_1}{e_2}{e_3} : \tau}\tag{T-IfEl}
\\
\inferrule
{\Gamma;\Phi \vdash e_1 : \tau_1
\ \Gamma;\Phi [x \mapsto \tau_1] \vdash e_2 : \tau_2}
{\Gamma;\Phi \vdash \letbind{x}{e_1}{e_2} : \tau_2}\tag{T-Let}
\\
\inferrule{\Gamma;\Phi \vdash e : (\tau_1, \tau_2)}
     {\Gamma;\Phi \vdash \pi_i\ e : \tau_i}
     {(i\in\{1,2\})}\tag{T-Proj}
\\
\inferrule{\Gamma;\Phi \vdash e : \tau}
     {\Gamma;\Phi \vdash \return\ e : \Lvalue\ \ell\ \tau}\tag{T-Ret}
\\
\inferrule
{\Gamma;\Phi \vdash e_1 : \Lvalue\ \ell\ \tau_1
 \\ \Gamma;\Phi \vdash e_2 : \tau_1 \rightarrow \Lvalue\ \ell\ \tau_2}
{\Gamma;\Phi \vdash e_1\ \bind\ e_2 : \Lvalue\ \ell\ \tau_2}\tag{T-Bind}
\\
\inferrule{\Gamma;\Phi \vdash e_1 : \ell\\ \Gamma;\Phi \vdash e_2 : \ell}
     {\Gamma;\Phi \vdash e_1\ \lub\ e_2 : \ell}\tag{T-Join}
\\
\inferrule{\Gamma;\Phi \vdash e_1 : \ell\\ \Gamma;\Phi \vdash e_2 : \ell}
     {\Gamma;\Phi \vdash e_1\ \glb\ e_2 : \ell}\tag{T-Meet}
\end{align}
\caption{Type rules for pure terms. The monadic return and bind are only
defined for type \Lvalue{}.}
\end{typerules}

\begin{sos}
\begin{align*}
&&E&   ::=  [\cdot]                    
       \ |\  E\ e                       
       \ |\  (E, e)                     
       \ |\  (v, E)                     
       \ |\  \Lv\ E\ e                    
       \ |\  \Lv\ v\ E                    
       \ |\  \ifel{E}{e}{e}
       \ |\  \letbind{x}{E}{e}
       \ |\  \pi_i\ E                     
       \\
&&&    \ |\  \return\ E                 
       \ |\  E\ \diamond\ e                
       \ |\  v\ \diamond\ E, \textrm{where }\diamond = \{\bind, \lub, \glb\}
       \\
\\
%
&&&E[(\lambda x.e_1)\ e_2] \longrightarrow E[[e_2/x]e_1] \tag{E-App}\\
%
&&&E[\fix\ e] \longrightarrow E[e\ (\fix\ e)] \tag{E-Fix}\\
%
&&&E[\ifel{\true}{e_1}{e_2}]  \longrightarrow E[e_1] \tag{E-IfTrue}\\
%
&&&E[\ifel{\false}{e_1}{e_2}] \longrightarrow E[e_2] \tag{E-IfFalse}\\
%
%&&&\inferrule
%                {e_1 \longrightarrow {e_1}^\prime}
%% --------------------------------------------------------------------------
%{E[\letbind{x}{e_1}{e_2}] \longrightarrow E[\letbind{x}{{e_1}^\prime}{e_2}]}
%\tag{E-Let}\\
%
%&&&E[\letbind{x}{v}{e}] \longrightarrow E[[v/x]e] \tag{E-Let}\\
%
%&&&E[\letbind{x}{v}{e}] \longrightarrow E[[v/x]e] \tag{E-Let}\\
&&&E[\letbind{x}{e_1}{e_2}] \longrightarrow E[[e_1/x]e] \tag{E-Let}\\
%
&&&E[\pi_i\ (e_1,e_2)] \longrightarrow E[e_i] \tag{E-Proj}\\
%
&&&E[\return\ e] \longrightarrow E[\Lv\ \lpure\ e] \tag{E-Ret}\\
%
&&&\inferrule
                        {e_2 \ne \Lv\ e_1^\prime\ e_2^\prime}
% --------------------------------------------------------------------------
{E[\Lv\ l_1\ e_1\ \bind\ \lambda x.e_2]
              \longrightarrow E[[e_1/x]e_2\ \bind\ \lambda x.\Lv\ l_1\ x]}
\tag{E-Bind}\\
%
&&&E[\Lv\ l_1\ e_1\ \bind\ \lambda x.\Lv\ l_2\ e_2]
        \longrightarrow E[\Lv\ (l_1\lub l_2)\ [e_1/x]e_2]\tag{E-RUnit}\\
%
&&&\inferrule
            {\labelOf{l_3} = \labelOf{l_1} \lub \labelOf{l_2}}
% --------------------------------------------------------------------------
            {E[l_1\ \lub\ l_2] \longrightarrow E[l_3]} \tag{E-Join}\\
%
&&&\inferrule
            {\labelOf{l_3} = \labelOf{l_1} \glb \labelOf{l_2}}
% --------------------------------------------------------------------------
           {E[l_1\ \glb\ l_2] \longrightarrow E[l_3]} \tag{E-Meet}
%
\end{align*}
\caption{Semantics for pure terms. These rewrite rules may be applied in 
any context.}
\label{sos:pure}
\end{sos}

\begin{typerules}
\begin{align}
\inferrule{\Gamma;\Phi \vdash e : \tau}
     {\Gamma;\Phi \vdash \lioValp{e} : \LIOp\ \tau}\tag{T-LIO$^\prime$-Val}
\\
\inferrule{\Gamma;\Phi \vdash e_1 : (\ell,\ell)
\\ \Gamma;\Phi \vdash e_2 : \LIOp\ \tau}
     {\Gamma;\Phi \vdash \withLblClr\ e_1\ e_2: \LIOp\ \tau}\tag{T-WithLblClr}
\\
\inferrule{\Gamma;\Phi \vdash e_1 : \ell \\ \Gamma;\Phi \vdash e_2 : \tau}
  {\Gamma;\Phi \vdash \seal\ e_1\ e_2: \LIOp\ (\Lvalue\ \ell\ \tau)}\tag{T-Seal}
\\
\inferrule{\Gamma;\Phi \vdash e : \Lvalue\ \ell\ \tau}
     {\Gamma;\Phi \vdash \open\ e : \LIOp\ \tau}\tag{T-Open}
\\
\inferrule{\Gamma;\Phi \vdash e : \LIOp\ \tau}
     {\Gamma;\Phi \vdash \close\ e : \LIOp\ (\Lvalue\ \ell\ \tau)}\tag{T-Close}
\\
\inferrule{\Gamma;\Phi \vdash e : \tau}
     {\Gamma;\Phi \vdash \returnLIOp\ e  : \LIOp\ \tau}\tag{T-LIO$^\prime$-Ret}
\\
\inferrule
{\Gamma;\Phi \vdash e_1 : \LIOp\ \tau_1
 \\ \Gamma;\Phi \vdash e_2 : \tau_1 \rightarrow \LIOp\ \tau_2}
{\Gamma;\Phi \vdash e_1\ \bindLIOp\ e_2 : \LIOp\ \tau_2}
\tag{T-LIO$^\prime$-Bind}
\\
\inferrule
{\Phi(a) = (\ell, \tau)}
{\Gamma;\Phi \vdash a : \Ref{\ell}{\tau}}\tag{T-RefAddr}
\\
\inferrule
{\Gamma;\Phi \vdash e_1 : \ell \\ \Gamma;\Phi \vdash e_2 : \tau}
{\Gamma;\Phi \vdash \newRef{e_1}{e_2}: \LIOp\ (\Ref{\ell}{\tau})}\tag{T-NewRef}
\\
\inferrule
{\Gamma;\Phi \vdash e : \Ref{\ell}{\tau}}
{\Gamma;\Phi \vdash \readRef{e}: \LIOp\ \tau}\tag{T-ReadRef}
\\
\inferrule
{\Gamma;\Phi \vdash e_1 : \Ref{\ell}{\tau} \\ \Gamma;\Phi \vdash e_2 : \tau}
{\Gamma;\Phi \vdash \writeRef{e_1}{e_2}: \LIOp\ \unit}\tag{T-WriteRef}
\end{align}
\caption{Type rules for terms with side-effects. Monadic return and
bind are distinct from those of \Lvalue{}.}
\end{typerules}


\begin{sos}
\begin{align*}
&&E&   ::=  \cdots
       \ |\  \lioValp{E}
       \ |\  \withLblClr\ E\ e
       \ |\  \seal\ E\ e
       \ |\  \seal\ v\ E
       \ |\  \open\ E                 
       \ |\  \close\ E\\
&&&    \ |\  \returnLIOp\ E
       \ |\  E\ \bindLIOp\ e
       \ |\  v\ \bindLIOp\ E
       \ |\  \newRef{E}{e}
       \ |\  \newRef{v}{E}
       \ |\  \writeRef{v}{E}
       \\
       \\
%
&&&\inferrule
              {\env[\lbl\mapsto l_1, \clr\mapsto l_2] \\ l_1 \flows l_2}
% --------------------------------------------------------------------------
{\langle \emptyset, E[\withLblClr\ (l_1, l_2)\ \lioValp{e}] \rangle
                        \longrightarrow \langle \env, E[\lioValp{e}]\rangle}
\tag{E-WithLblClr}\\
%
&&&\inferrule
             {\env(\lbl) \flows l_1 \flows \env(\clr)}
% --------------------------------------------------------------------------
{\langle \env, E[\seal\ l_1\ e]\rangle
            \longrightarrow \langle \env, E[\lioValp{\Lv\ l_1\ e}]\rangle}
\tag{E-Seal}\\
%
&&&\inferrule
{l^\prime = \env(\lbl) \lub l_1 \\ l^\prime \flows \env(\clr)
                           \\ \env^\prime = \env[\lbl \mapsto l^\prime]}
% --------------------------------------------------------------------------
{\langle \env, E[\open\ (\Lv\ l_1\ e_1)]\rangle
             \longrightarrow \langle \env^\prime, E[\lioValp{e_1}]\rangle}
\tag{E-Open} \\
%
&&&\inferrule
{\langle \env, \lioValp{e} \rangle
    \longrightarrow^* \langle \env^\prime, \lioValp{v} \rangle
\\ \env(\lbl) \flows \env^\prime(\lbl)
    \flows \env^\prime(\clr) \flows \env(\clr)
\\ l = \env^\prime(\lbl)}
% --------------------------------------------------------------------------
{\langle \env, E[\close\ \lioValp{e}]\rangle
  \longrightarrow \langle \env, E[\lioValp{\Lv\ l\ v}]\rangle}
\tag{E-Close} \\
%
&&&E[\returnLIOp\ e] \longrightarrow E[\lioValp{e}] \tag{E-LIO$^\prime$-Ret}\\
%
&&&E[\lioValp{e_1}\ \bindLIOp\ \lambda x. e_2] \longrightarrow E[[e_1/x]e_2]
\tag{E-LIO$^\prime$-Bind}\\
%
&&&E[\lioValp{e_1}\ \bindLIOp\ \lambda x. \returnLIOp\ x]
           \longrightarrow E[\lioValp{e_1}] \tag{E-LIO$^\prime$-RUnit} \\
%
&&&\inferrule
{a \not\in\dom(\str) \\ \str^\prime=\str[a\mapsto (l,e)]
\\ \env(\lbl)\flows l
\\ l^\prime=\env(\lbl)\lub l
\\ l^\prime \flows \env(\clr)
\\ \env^\prime=\env[\lbl\mapsto l^\prime]
}
{\langle \env;\str, E[\newRef{l}{e}]\rangle \longrightarrow
\langle \env^\prime;\str^\prime, E[\lioValp{a}]\rangle}
\tag{E-NewRef}\\
%
&&&\inferrule
{\str(a)=(l,e)
\\ l^\prime=\env(\lbl)\lub l
\\ l^\prime \flows \env(\clr)
\\ \env^\prime=\env[\lbl\mapsto l^\prime]
}
{\langle \env;\str, E[\readRef{a}]\rangle \longrightarrow
\langle \env^\prime;\str, E[\lioValp{e}]\rangle}
\tag{E-ReadRef}\\
%
&&&\inferrule
{\str(a)=(l,e)
\\\str^\prime=\str[a\mapsto (l,e^\prime)]
\\ \env(\lbl)\flows l
\\ l^\prime=\env(\lbl)\lub l
\\ l^\prime \flows \env(\clr)
\\ \env^\prime=\env[\lbl\mapsto l^\prime]
}
{\langle \env;\str, E[\writeRef{a}{e^\prime}]\rangle \longrightarrow
\langle \env^\prime;\str^\prime, E[\lioValp{\unit}]\rangle}
\tag{E-WriteRef}
%
\end{align*}
\caption{Semantics for terms with side effects.}
\label{sos:sideeffect}
\end{sos}


\pagebreak


\begin{example}[Example with no side-effects]\label{ex:pure}
Let us consider a simple example, working only on pure terms. In this example
we are given two labeled values, one public, with a label \lL{}, and another,
secret, with label \lH. Adding the two we expect the resulting value to be
labeled \lH.

\begin{align*}
&                     && \fbox{\Lv\ \lL\ 1}\ \bind\ \lambda x.\
                         \Lv\ \lH\ 2\ \bind\ \lambda y.\
                         \return\ (x + y) \\
&\tref{E-Bind}:        & \longrightarrow &
                         \fbox{\Lv\ \lH\ 2}\ \bind\ \lambda y.
                         \return\ (1 + y)\
                         \bind\ \lambda x.\Lv\ \lL\ x\\
&\tref{E-Bind}:        & \longrightarrow &
                         \return\ \fbox{(1 + 2)}\
                         \bind\ \lambda x.\Lv\ \lL\ x
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-Add}:         & \longrightarrow &
                         \fbox{\return\ 3}\
                         \bind\ \lambda x.\Lv\ \lL\ x
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-Ret}:         & \longrightarrow &
                         \fbox{$\Lv\ \lpure\ 3$}\ 
                         \bind\ \lambda x.\Lv\ \lL\ x
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-RUnit}:       & \longrightarrow &
                         \Lv\ (\fbox{$\lpure\lub\lL$})\ 3\ 
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-Join}:        & \longrightarrow &
                         \fbox{\Lv\ \lL\ 3}\ 
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-RUnit}:       & \longrightarrow &
                         \Lv\ (\fbox{$\lL\lub\lH$})\ 3\\
&\tref{E-Join}:        & \longrightarrow &
                         \Lv\ \lH\ 3\\
\end{align*}
\end{example}

\begin{example}[Example with side-effects]\label{ex:sideeffect}
Let us consider a more complex example, a full program, that type checks and
does not violate the information flow constraints.
For simplicity, and since Example~\ref{ex:pure} is a special case of $f$, we
do not expand $f$.
\begin{align*}
&                     && {\tt let}\ f\ =\lambda x_l. \lambda y_l. x_l\ \bind\
                                        \lambda x. y_l\ \bind\
                                        \lambda y. \return\ (x + y)\\
&                     && {\tt in}\ \withLblClr\ (\lL, \lH)\ (\
                                \seal\ \lL\ 1\ \bindLIOp\ \lambda x.  
                                \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                \open\ (f\ x\ y)\ )\\
&\tref{E-Let}:        & \longrightarrow & \langle \emptyset,
                                          \fbox{$\withLblClr\ (\lL, \lH)\ (\
                                          \seal\ \lL\ 1\ \bindLIOp\ \lambda x.  
                                          \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ x\ y)\ )$}\rangle\\
&\tref{E-WithLblClr}: & \longrightarrow & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \fbox{\seal\ \lL\ 1}\ \bindLIOp\
                                          \lambda x.  
                                          \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ x\ y) \rangle\\
&\tref{E-Seal}:   & \longrightarrow & \langle \{(\lbl,\lL),(\clr,\lH)\}, 
                                          \fbox{$\lioValp{\Lv\ \lL\ 1}$}\
                                          \bindLIOp\
                                          \lambda x.  
                                          \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ x\ y) \rangle\\
&\tref{E-LIO$^\prime$-Bind}:
                      & \longrightarrow & \langle \{(\lbl,\lL),(\clr,\lH)\}, 
                                          \fbox{\seal\ \lH\ 2}\ \bindLIOp\
                                          \lambda y. 
                                          \open\ (f\ (\Lv\ \lL\ 1) \ y)\rangle\\
&\tref{E-Seal}:   & \longrightarrow & \langle \{(\lbl,\lL),(\clr,\lH)\}, 
                                          \fbox{$\lioValp{\Lv\ \lH\ 2}$}\
                                          \bindLIOp\
                                          \lambda y. 
                                          \open\ (f\ (\Lv\ \lL\ 1) \ y)\rangle\\
&\tref{E-LIO$^\prime$-Bind}:
                      & \longrightarrow & \langle \{(\lbl,\lL),(\clr,\lH)\}, 
                                          \open\ (\fbox{f\ (\Lv\ \lL\ 1)\
                                                     (\Lv\ \lH\ 2)}) \rangle\\
&\textrm{Evaluate $f$}:
                      & \longrightarrow^* & \langle \{(\lbl,\lL),(\clr,\lH)\}, 
                                          \fbox{\open\ (\Lv\ \lH\ 3)} \rangle\\
&\tref{E-Open}:   & \longrightarrow & \langle \{(\lbl,\lH),(\clr,\lH)\}, 
                                          \lioValp{3} \rangle\\
\end{align*}
\end{example}

\begin{example}[Example with side-effects and no label-raising]
Let us reconsider the above example using \close{} to prevent final current
label increase.
For simplicity, we do not repeat the steps shown in the previous example.
\begin{align*}
&                     && {\tt let}\ f\ =\lambda x_l. \lambda y_l. x_l\ \bind\ 
                                        \lambda x.  y_l\ \bind\
                                        \lambda y.  \return\ (x + y)\\
&                     && {\tt in}\ \withLblClr\ (\lL, \lH)\ (\ \close\ (
                                \seal\ \lL\ 1\ \bindLIOp\ \lambda x.  
                                \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                \open\ (f\ x\ y))\ )\\
&\tref{E-Let}:        & \longrightarrow & \langle \emptyset,\fbox{$
                                          \withLblClr\ (\lL, \lH)\ (\ \close\ (
                                          \seal\ \lL\ 1\ \bindLIOp\ \lambda x.  
                                          \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ x\ y))\ )$}\rangle\\
&\tref{E-WithLblClr}: & \longrightarrow & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \fbox{$\close\ (
                                            \seal\ \lL\ 1\ \bindLIOp\ \lambda x.
                                            \seal\ \lH\ 2\ \bindLIOp\ \lambda y.
                                            \open\ (f\ x\ y)
                                               )$} \rangle\\
&\tref{E-Close}:   & \longrightarrow &
\inferrule{\textrm{\footnotesize $
    \langle \{(\lbl,\lL),(\clr,\lH)\}, 
    \lioValp{\Lv\ \lL\ 1}\ \bindLIOp\ \lambda x.  
    \seal\ 2\ \lH\ \bindLIOp\ \lambda y. 
    \open\ (f\ x\ y) \rangle
    \longrightarrow^{*}
    \langle \{(\lbl,\lH),(\clr,\lH)\}, 
    \lioValp{3} \rangle$}}
    {\langle \{(\lbl,\lL),(\clr,\lH)\}, \lioValp{\Lv\ \lH\ 3}\rangle}
\end{align*}
\end{example}

\begin{example}[Example with side-effects that violates information flow]
As above, we consider a full program, but in this case one that would violates
information flow (flow from a secret value to a public value).
\begin{align*}
&                     && \langle \emptyset, \fbox{$\withLblClr\ (\lL, \lH)\ (\
                         \seal\ \lH\ 1\ \bindLIOp\ \lambda x.  
                         \open\ x\ \bindLIOp\ \lambda y. 
                         \seal\ \lL\ y)$}\rangle\\
&\tref{E-WithLblClr}: & \longrightarrow & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \fbox{$\seal\ \lH\ 1$}\
                                          \bindLIOp\ \lambda x.  
                                          \open\ x\ \bindLIOp\ \lambda y. 
                                          \seal\ \lL\ y)\rangle\\
&\tref{E-Seal}:   & \longrightarrow & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \fbox{$\lioValp{\Lv\ \lH\ 1}$}\
                                          \bindLIOp\
                                          \lambda x.  
                                          \open\ x\ \bindLIOp\ \lambda y. 
                                          \seal\ \lL\ y\rangle\\
&\tref{E-LIO$^\prime$-Bind}:
                      & \longrightarrow & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \open\ (\fbox{$\Lv\ \lH\ 1$})\
                                          \bindLIOp\
                                          \lambda y. 
                                          \seal\ \lL\ y\rangle\\
&\tref{E-Open}:   & \longrightarrow & \langle \{(\lbl,\lH),(\clr,\lH)\},
                                          \fbox{$\lioValp{1}$}\ \bindLIOp\
                                          \lambda y. 
                                          \seal\ \lL\ y\rangle\\
&\tref{E-LIO$^\prime$-Bind}:
                      & \longrightarrow & \langle \{(\lbl,\lH),(\clr,\lH)\},
                                          \fbox{$\seal\ \lL\ 1$}\rangle\\
&\tref{E-Seal}:   & \texttt{STUCK: }& \textrm{Premise for rule is not
                                               satisfied: $\lH \not\flows \lL$.}
\end{align*}
\end{example}







\subsection{Language properties}
\begin{definition}[Environment equivalence]
Equivalence of two environments $\env$ and $\env^\prime$ is given by:
\begin{equation*}
\inferrule
  {\dom(\env) = \dom(\env^\prime) \\
  \forall x\in \dom(\env).\ \env(x)=\env^\prime(x)}
  {\env \cong \env^\prime}.
\end{equation*}
\end{definition}

\begin{definition}[Pure term]
A pure term $e$ does not depend on the environment and may take an evaluation
step regardless of whether the environment is empty or not. The semantics of
pure terms is given in Operational~Semantics~\ref{sos:pure}.
\end{definition}

\begin{proposition}[Determinacy of $(\longrightarrow)$]
\label{proposition:determinacy-eval}
\quad
\begin{itemize}
\item
For term $e$ there is a unique term $e^\prime$ and unique evaluation context
$E$: $e = E[e^\prime]$.
%
\item
If $e \longrightarrow\ e^\prime$ and $e \longrightarrow\ e^\second$
then $e^\prime = e^\second$.
%
\item
If
$\langle\env, e\rangle
      \longrightarrow\ \langle\env^\prime, e^\prime\rangle$
and
$\langle \env, e \rangle
      \longrightarrow\ \langle\env^\second e^\second\rangle$
then $e^\prime = e^\second$ and $\env^\prime\cong\env^\second$.
\end{itemize}
\end{proposition}
\begin{proof}
By induction on terms and evaluation contexts.
\end{proof}



\begin{lemma}[Type preservation under information flow preservation]
\label{lemma:type-flow-preservation}
If $\vdash e : \tau$, and
$\langle \env, e\rangle \longrightarrow
  \langle \env^\prime, e^\prime \rangle$ then $\vdash e^\prime : \tau$.
\end{lemma}
\begin{proofidea}
Follows directly from the typing derivations.
\end{proofidea}
A well-typed term taking an evaluation step results in a term that is also
well-typed. Note that if a term takes an evaluation step, then it has not
violated information flow. Since information flow control rules are described
as premises to evaluation rules, an information flow violation results
in a term getting stuck. Note that this lemma encompasses the pure case
where $\env=\emptyset$.

Proving progress for the pure case, i.e., terms that do not depend on an 
environment is standard. However, the proof of progress for terms relying
on an environment, e.g., \seal{}, requires the definition of ``well-behaved''
terms. A term that does not violate the information flow control premises
of an evaluation rule is said to be well-behaved. At each step, a well-typed
and well-behaved term is either a value or it can progress.
Conversely, a well-typed but information flow violating term does not progress.


\subsection{Security properties}

The main security properties we are interested in are non-interference and
confinement. In formalizing and proving our security guarantees we introduce
a new syntactic term, `$\hole$', that denotes an ``erased'' term.
\begin{language}
\begin{align*}
&& e    &\Coloneqq  \cdots\ |\ \hole
\end{align*}
\caption{Extending language with erased terms}
\end{language}

Terms are then erased to a $\hole$ according to the label-dependent erasure
function $\erase{L}{e}$, that we define below:
\begin{align*}
\erase{L}{\hole} &= \hole\\
\erase{L}{x} &= x\\
\erase{L}{\lambda x. e} &= \lambda x.\erase{L}{e}\\
\erase{L}{\true} &= \true\\
\erase{L}{\false} &= \false\\
\erase{L}{l} &= l\\
\erase{L}{\fix\ e} &= \fix\ \erase{L}{e}\\
\\
\erase{L}{[\cdot]}&=[\cdot]\\
\erase{L}{E\ e} &= \erase{L}{E}\ \erase{L}{e}\\
\erase{L}{(E,e)}  &= (\erase{L}{E}, \erase{L}{e})\\
\erase{L}{(v,E)}  &= (\erase{L}{v}, \erase{L}{E})\\
\erase{L}{\Lv\ E\ e} &= \begin{cases}
                          \Lv\ \erase{L}{E}\ \hole & \erase{L}{E} \not\flows L\\
                          \Lv\ \erase{L}{E}\ \erase{L}{e} & \textrm{otherwise}\\
                        \end{cases}\\
\erase{L}{\Lv\ l\ E} &= \begin{cases}
                          \Lv\ l\ \hole &  l \not \flows L\\
                          \Lv\ l\ \erase{L}{E} & \textrm{otherwise}\\
                        \end{cases}\\
\erase{L}{\ifel{E}{e}} &= \ifel{\erase{L}{E}}{\erase{L}{e}}{\erase{L}{e}} \\
\erase{L}{\letbind{x}{E}{e}} &= \letbind{x}{\erase{L}{E}}{\erase{L}{e}} \\
\erase{L}{\pi_i\ E}  &= \pi_i\ \erase{L}{E}\\
\erase{L}{\return\ E}  &= \return\ \erase{L}{E}\\
\erase{L}{E\ \diamond\ e}  &= \erase{L}{E}\ \diamond\ \erase{L}{e}
                      \textrm{, where }\diamond = \{\bind, \lub, \glb\} \\
\\
\erase{L}{\withLblClr\ E\ e}&= \withLblClr\ \erase{L}{E}\ \erase{L}{e}\\
\erase{L}{\seal\ E\ e}          &= \seal\ \erase{L}{E}\ \erase{L}{e}\\
\erase{L}{\seal\ v\ E}          &= \seal\ \erase{L}{v}\ \erase{L}{E}\\
\erase{L}{\open\ E}             &= \open\ \erase{L}{E}\\
\erase{L}{\close\ E}             &= \close\ \erase{L}{E}\\
\erase{L}{\returnLIOp\ E} &= \returnLIOp\ \erase{L}{E}\\
\erase{L}{E\ \bindLIOp\ e}  &= \erase{L}{E}\ \bindLIOp\ \erase{L}{e}\\
\erase{L}{v\ \bindLIOp\ E}  &= \erase{L}{v}\ \bindLIOp\ \erase{L}{E}\\
\erase{L}{\lioValp{E}} &= \lioValp{\erase{L}{E}} \\
\end{align*}

Informally, to an observer reading labeled values with label at most $L$,
a computation $e$ is not distinguishable from $e^\prime$, where $e^\prime$ is 
$e$ with all values labeled above $L$ erased to $\hole$.
To prove our security guarantees we need to define a new evaluation relation, 
${\longrightarrow_L}$, that performs the term erasures. For pure terms,
%
\begin{equation*}
\inferrule{e \longrightarrow e^\prime}
          {e \longrightarrow_L \erase{L}{e^\prime}}
\end{equation*}
%
and, similarly, for terms in an environment,
%
\begin{equation*}
\inferrule
{\langle \env, e \rangle
            \longrightarrow \langle \env^\prime, e^\prime \rangle}
%-------------------------------------------------------------------------------
{\langle \env, e \rangle
           \longrightarrow_L \langle \env^\prime, \erase{L}{e^\prime} \rangle}
\end{equation*}

\begin{proposition}[Determinacy of $(\longrightarrow_L)$]
\label{proposition:determinacy-evalL}
\item
If $e \longrightarrow_L\ e^\prime$ and
$e \longrightarrow_L\ e^\second$ then $e^\prime = e^\second$.
%
\item
If
$\langle\env, e\rangle
      \longrightarrow_L\ \langle\env^\prime, e^\prime\rangle$
and
$\langle \env, e \rangle
      \longrightarrow_L\ \langle\env^\second e^\second\rangle$
then $e^\prime = e^\second$ and $\env^\prime\cong\env^\second$.
\end{proposition}
\begin{proof}
From Proposition~\ref{proposition:determinacy-eval} and definition
of $\erase{L}{\cdot}$.
\end{proof}

\begin{example}[Example with term erasure on pure terms]
Let us consider Example~\ref{ex:pure}, working only on pure terms, and 
using the erasure function $\erase{\lL}{\cdot}$.
\begin{align*}
&                     && \fbox{\Lv\ \lL\ 1}\ \bind\ \lambda x.\
                         \Lv\ \lH\ 2\ \bind\ \lambda y.\
                         \return\ (x + y) \\
&\tref{E-Bind}:        & \longrightarrow_\lL\  &
                         \fbox{$\Lv\ \lH\ \hole$}\ \bind\ \lambda y.
                         \return\ (1 + y)\
                         \bind\ \lambda x.\Lv\ \lL\ x\\
&\tref{E-Bind}:        & \longrightarrow_\lL\  &
                         \return\ \fbox{$(1 + \hole)$}\
                         \bind\ \lambda x.\Lv\ \lL\ x
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-Add}:         & \longrightarrow_\lL\  &
                         \fbox{$\return\ \hole$}\
                         \bind\ \lambda x.\Lv\ \lL\ x
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-Ret}:         & \longrightarrow_\lL\  &
                         \fbox{$\Lv\ \lpure\ \hole$}\ 
                         \bind\ \lambda x.\Lv\ \lL\ x
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-RUnit}:       & \longrightarrow_\lL\  &
                         \Lv\ (\fbox{$\lpure\lub\lL$})\ \hole\ 
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-Join}:        & \longrightarrow_\lL\  &
                         \fbox{$\Lv\ \lL\ \hole$}\ 
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-RUnit}:       & \longrightarrow_\lL\  &
                         \Lv\ (\fbox{$\lL\lub\lH$})\ \hole\\
&\tref{E-Join}:        & \longrightarrow_\lL\  &
                         \Lv\ \lH\ \hole\\
\end{align*}
\end{example}

\begin{example}[Example with term erasure on terms with side-effects]
Let us consider Example~\ref{ex:sideeffect}, working on terms with
side-effects, and using the erasure function $\erase{\lL}{\cdot}$.
\begin{align*}
&                     && {\tt let}\ f\ =\lambda x_l. \lambda y_l. x_l\ \bind\
                                        \lambda x. y_l\ \bind\
                                        \lambda y. \return\ (x + y)\\
&                     && {\tt in}\ \withLblClr\ (\lL, \lH)\ (\
                                \seal\ \lL\ 1\ \bindLIOp\ \lambda x.  
                                \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                \open\ (f\ x\ y)\ )\\
&\tref{E-Let}:        & \longrightarrow_\lL\  & \langle \emptyset,
                                          \fbox{$\withLblClr\ (\lL, \lH)\ (\
                                          \seal\ \lL\ 1\ \bindLIOp\ \lambda x.  
                                          \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ x\ y)\ )$}\rangle\\
&\tref{E-WithLblClr}:
                      &\longrightarrow_\lL\ & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \fbox{\seal\ \lL\ 1}\ \bindLIOp\
                                          \lambda x.  
                                          \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ x\ y) \rangle\\
&\tref{E-Seal}:   &\longrightarrow_\lL\ & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \fbox{$\lioValp{\Lv\ \lL\ 1}$}\
                                          \bindLIOp\
                                          \lambda x.  
                                          \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ x\ y) \rangle\\
&\tref{E-LIO$^\prime$-Bind}:
                      &\longrightarrow_\lL\ & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \fbox{\seal\ \lH\ 2}\ \bindLIOp\
                                          \lambda y. 
                                          \open\ (f\ (\Lv\ \lL\ 1) \ y)\rangle\\
&\tref{E-Seal}:   &\longrightarrow_\lL\ & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \fbox{$\lioValp{\Lv\ \lH\ \hole}$}\
                                          \bindLIOp\
                                          \lambda y. 
                                          \open\ (f\ (\Lv\ \lL\ 1) \ y)\rangle\\
&\tref{E-LIO$^\prime$-Bind}:
                      &\longrightarrow_\lL\ & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \open\ (\fbox{$f\ (\Lv\ \lL\ 1)\
                                                 (\Lv\ \lH\ \hole)$}) \rangle\\
&\textrm{Evaluate $f$}:
                     &\longrightarrow_\lL^*\ &\langle \{(\lbl,\lL),(\clr,\lH)\},
                                     \fbox{$\open\ (\Lv\ \lH\ \hole)$} \rangle\\
&\tref{E-Open}:   &\longrightarrow_\lL\ & \langle \{(\lbl,\lH),(\clr,\lH)\},
                                          \lioValp{\hole} \rangle\\
\end{align*}
\end{example}

\begin{proposition}[Properties of $ \varepsilon_L $]\label{proposition:erase}
\quad
\begin{enumerate}
\item $\erase{L}{E[e]} = \erase{L}{E}[\erase{L}{e}]$
\item $\erase{L}{[e_2/x]e_1} = [\erase{L}{e_2}/x]\erase{L}{e_1}$
\item $\erase{L}{\erase{L}{e}} = \erase{L}{e}$
\item $\erase{L}{\erase{L}{E}} = \erase{L}{E}$
\item $\inferrule
              {\erase{L}{E}[e] \longrightarrow \erase{L}{E}[e^\prime] }
          % -------------------------------------------------------------------
          {\erase{L}{E}[e] \longrightarrow_L \erase{L}{E}[\erase{L}{e^\prime}] }
      $
\end{enumerate}
\end{proposition}
\begin{proof}
\quad
\begin{enumerate}
%
\item All follow directly from the induction on evaluation contexts and terms.
      We show several cases below.
  \begin{enumerate}
  \item Let $E := [\cdot]\ e_0$, it follows that
        $\erase{L}{E} := [\cdot]\ \erase{L}{e_0}$, and\\
        ${\erase{L}{E[e]}=\erase{L}{e\ e_0}=\erase{L}{e}\ \erase{L}{e_0}
                         =\erase{L}{E}[\erase{L}{e}]}$
  \item Let $E := ([\cdot], e_0)$, it follows that
        $\erase{L}{E} := ([\cdot], \erase{L}{e_0})$, and\\
        ${\erase{L}{E[e]}=\erase{L}{(e, e_0)}=(\erase{L}{e}, \erase{L}{e_0})
                         =\erase{L}{E}[\erase{L}{e}]}$
  \item $ E := (v, [\cdot])$ is as above.
  \item Let $ E := \Lv\ [\cdot]\ e_0$, it follows that 
        \begin{equation*}
         \erase{L}{E} := \begin{cases}
                      \Lv\ [\cdot]\ \hole &  [\cdot] \not \flows L\\
                      \Lv\ [\cdot]\ \erase{L}{e_0} & \textrm{otherwise}\\
                    \end{cases}
        \end{equation*}
        and
        \begin{equation*}
        \erase{L}{E[e]}=\erase{L}{\Lv\ e\ e_0}=
                              \begin{cases}
                                 \Lv\ e\ \hole &  e \not \flows L\\
                                 \Lv\ e\ \erase{L}{e_0} & \textrm{otherwise}\\
                              \end{cases},
        \end{equation*}
        from which $\erase{L}{E[e]} = \erase{L}{E}[\erase{L}{e}]$ follows
        directly.
  \item Let $ E := \Lv\ l\ [\cdot]$, it follows that 
        \begin{equation*}
         \erase{L}{E} := \begin{cases}
                      \Lv\ l\ \hole &  l \not \flows L\\
                      \Lv\ l\ \erase{L}{[\cdot]} & \textrm{otherwise}\\
                    \end{cases}
        \end{equation*}
        and
        \begin{equation*}
        \erase{L}{E[e]}=\erase{L}{\Lv\ l\ e}=
                            \begin{cases}
                               \Lv\ l\ \hole &  l \not \flows L\\
                               \Lv\ l\ \erase{L}{e} & \textrm{otherwise}\\
                            \end{cases},
        \end{equation*}
        from which $\erase{L}{E[e]} = \erase{L}{E}[\erase{L}{e}]$ follows
        directly.
  \end{enumerate}
%
\item $\erase{L}{[e_2/x]e_1} = \erase{L}{ (\lambda x . e_1)\ e_2}
       = \erase{L}{\lambda x . e_1}\ \erase{L}{e_2}
       = \lambda x . \erase{L}{e_1}\ \erase{L}{e_2}
       = [\erase{L}{e_2}/x]\erase{L}{e_1}
      $
%
\item Directly from definition of the erasure function and induction on terms.
%
\item Directly from definition of the erasure function and induction on terms
      and evaluation contexts.
%
\item From the property of evaluation contexts: 
  \begin{equation*}
  \inferrule{e \longrightarrow e^\prime}{E[e] \longrightarrow E[e^\prime]},
  \end{equation*}
  definition of $\longrightarrow_L$, and properties 2 and 4, above, we have 
  \begin{equation*}
  \inferrule
          {E[e] \longrightarrow E[e^\prime]}
    % --------------------------------------------
    {E[e] \longrightarrow_L \erase{L}{E[e^\prime]}}
  =\inferrule
               {E[e] \longrightarrow E[e^\prime]}
    % -------------------------------------------------------
    {E[e] \longrightarrow_L \erase{L}{E}[\erase{L}{e^\prime}]}
  =\inferrule
      {\erase{L}{E^\prime}[e] \longrightarrow \erase{L}{E^\prime}[e^\prime]}
    % ----------------------------------------------------------------------
    {\erase{L}{E^\prime}[e]
                \longrightarrow_L \erase{L}{E^\prime}[\erase{L}{e^\prime}] },
    \textrm{ for some $E=\erase{L}{E^\prime}$}.
  \end{equation*}
%
\end{enumerate}
\end{proof}


\begin{lemma}[Single-step simulation without close]
\label{lemma:single-step-noclose}
If $\Gamma \vdash e : \tau$, $e$ does not contain any \close{} terms, and
${\langle \env, e \rangle
       \longrightarrow \langle \env^\prime, e^\prime\rangle}$
then 
$ \Gamma \vdash e^\prime : \tau$, and
${\langle \env, \erase{L}{e} \rangle
       \longrightarrow_L \langle \env^\prime, \erase{L}{e^\prime\rangle}}$.
\end{lemma}
\begin{proof}
Lemma~\ref{lemma:type-flow-preservation} proves type preservation, so we limit
the proof to the simulation.
In most cases we do not show the environment in the simulation, for clarity.
\begin{enumerate}
\item Case: $E[(\lambda x. e_1)\ e_2] \longrightarrow  E[ [e_2/x]e_1]$:
  \begin{align*}
  &\ \el{E[(\lambda x. e_1)\ e_2]} = \el{E}[\el{(\lambda x. e_1)\ e_2}]
                                   = \el{E}[(\lambda x. \el{e_1})\ \el{e_2}]\\
  \longrightarrow_L &\  
   \el{\el{E}[{[\el{e_2}/x]\el{e_1}}]} =\el{\el{E}}[\el{[\el{e_2}/x]\el{e_1}}]
                                       =\el{E}[\el{[\el{e_2}/x]\el{e_1}}]\\ 
  &\ = \el{E}[{[\el{e_2}/x]\el{e_1}}]
     = \el{E}[\el{[e_2/x]e_1}]
     = \el{E[[e_2/x]e_1]} \textrm{ by Proposition~\ref{proposition:erase}.}
  \end{align*}
%
\item Case: $E[\fix\ e] \longrightarrow E[e (\fix\ e)]$:
  \begin{align*}
  &\ \el{E[\fix\ e]} = \el{E}[\el{\fix\ e}]= \el{E}[\fix\ \el{e}]\\
  \longrightarrow_L &\  
  \el{\el{E}[\el{e}\ (\fix\ \el{e})]}
  = \el{E}[\el{e}\ (\fix\ \el{e})]\\
  &\ = \el{E}[\el{e\ (\fix\ e)}]
  = \el{E[e\ (\fix\ e)]} \textrm{ by definition of $\el{\cdot}$ and
                                  Proposition~\ref{proposition:erase}.}
  \end{align*}
%
\item Case: $E[\ifel{\true}{e_1}{e_2}] \longrightarrow E[e_1]$: \\
  Follows similarly.
%
\item Case: $E[\ifel{\false}{e_1}{e_2}] \longrightarrow E[e_2]$: \\
  Follows similarly.
%
%\item Case: $\inferrule
%             {e_1 \longrightarrow {e_1}^\prime}
%  %-----------------------------------------------------------------------------
%  {E[\letbind{x}{e_1}{e_2}] \longrightarrow E[\letbind{x}{{e_1}^\prime}{e_2}]}$:
%  \\ Follows similarly.
%
\item Case: $E[\letbind{x}{e_1}{e_2}] \longrightarrow E[[e_1/x]e_2]$:\\
  Follows similarly.
%
\item Case: $E[\pi_i\ (e_1,e_2)]  \longrightarrow E[e_i]$:\\
  Follows similarly.
%
\item Case: $E[\return\ e]\longrightarrow E[\Lv\ \lpure\ e]$:
  \begin{itemize}
  \item $\lpure \flows L$:
        \begin{align*}
        &\ \el{E[\return\ e]}
        = \el{E}[\el{\return\ e}]
        = \el{E}[\return\ \el{e}]\\
        \longrightarrow_L &\  
        \el{\el{E}[\Lv\ \lpure\ \el{e}]}
        =\el{E}[\el{\Lv\ \lpure\ \el{e}}]
        =\el{E}[\Lv\ \lpure\ \el{e}]\\
        &\ =\el{E}[\el{\Lv\ \lpure\ e}]
           =\el{E[\Lv\ \lpure\ e]}
        \end{align*}
  \item $\lpure \not\flows L$:
        \begin{align*}
        &\ \el{E[\return\ e]}
        = \el{E}[\el{\return\ e}]
        = \el{E}[\return\ \el{e}]\\
        \longrightarrow_L &\  
        \el{\el{E}[\Lv\ \lpure\ \el{e}]}
        =\el{E}[\el{\Lv\ \lpure\ \el{e}}]
        =\el{E}[\Lv\ \lpure\ \hole]\\
        &\ =\el{E}[\el{\Lv\ \lpure\ \hole}]
           =\el{E[\Lv\ \lpure\ \hole]}
           =\el{E[\Lv\ \lpure\ e]}
        \end{align*}
  \end{itemize}
%
\item Case: $\inferrule
                      {e_2 \ne \Lv\ e_l\ e_2^\prime}
         % ------------------------------------------------------------
         {E[\Lv\ l_1\ e_1\ \bind\ \lambda x.e_2]
           \longrightarrow E[[e_1/x]e_2\ \bind\ \lambda x.\Lv\ l_1\ x]}$:
  \begin{itemize}
  \item $l_1 \flows L$:
        \begin{align*}
        &\ \el{E[\Lv\ l_1\ e_1\ \bind\ \lambda x.e_2]}
        = \el{E}[\el{\Lv\ l_1\ e_1\ \bind\ \lambda x.e_2}]
        = \el{E}[\Lv\ l_1\ \el{e_1}\ \bind\ \lambda x.\el{e_2}]\\
        \longrightarrow_L &\  
        \el{\el{E}[[\el{e_1}/x]\el{e_2}\ \bind\ \lambda x.\Lv\ l_1\ x]}
        = \el{E}[\el{[\el{e_1}/x]\el{e_2}\ \bind\ \lambda x.\Lv\ l_1\ x}]\\
        &\ = \el{E}[[\el{e_1}/x]\el{e_2}\ \bind\ \lambda x.\Lv\ l_1\ x]
           = \el{E}[\el{[e_1/x]e_2\ \bind\ \lambda x.\Lv\ l_1\ x}]\\
        &\ = \el{E[[e_1/x]e_2\ \bind\ \lambda x.\Lv\ l_1\ x]}
        \end{align*}
  \item $l_1 \not\flows L$:
        \begin{align*}
        &\ \el{E[\Lv\ l_1\ e_1\ \bind\ \lambda x.e_2]}
        = \el{E}[\el{\Lv\ l_1\ e_1\ \bind\ \lambda x.e_2}]
        = \el{E}[\Lv\ l_1\ \hole\ \bind\ \lambda x.\el{e_2}]\\
        \longrightarrow_L &\  
        \el{\el{E}[[\hole/x]\el{e_2}\ \bind\ \lambda x.\Lv\ l_1\ x]}
        = \el{E}[\el{[\hole/x]\el{e_2}\ \bind\ \lambda x.\Lv\ l_1\ x}]\\
        &\ = \el{E}[[\hole/x]\el{e_2}\ \bind\ \lambda x.\Lv\ l_1\ \hole]
           = \el{E}[\el{[\hole/x]e_2\ \bind\ \lambda x.\Lv\ l_1\ \hole}]\\
        &\ = \el{E[[\hole/x]e_2\ \bind\ \lambda x.\Lv\ l_1\ \hole]}
           = \el{E[[e_1/x]e_2\ \bind\ \lambda x.\Lv\ l_1\ x]}
        \end{align*}
  \end{itemize}
%
\item Case: $E[\Lv\ l_1\ e_1\ \bind\ \lambda x.\Lv\ l_2\ e_2]
                  \longrightarrow E[\Lv\ (l_1\lub l_2)\ [e_1/x]e_2]$:
  \begin{itemize}
  \item $l_1 \flows L \land l_2 \flows L$:
        \begin{align*}
        &\  \el{E[\Lv\ l_1\ e_1\ \bind\ \lambda x.\Lv\ l_2\ e_2]}
           = \el{E}[\Lv\ l_1\ \el{e_1}\ \bind\ \lambda x.\Lv\ l_2\ \el{e_2}] \\
        \longrightarrow_L &\
           \el{\el{E}[\Lv\ (l_1\lub l_2)\ [\el{e_1}/x]\el{e_2}]}
           =  \el{E}[\Lv\ (l_1\lub l_2)\ [\el{e_1}/x]\el{e_2}]\\
        &\ =   \el{E}[\el{\Lv\ (l_1\lub l_2)\ [e_1/x]e_2}]
           =   \el{E[\Lv\ (l_1\lub l_2)\ [e_1/x]e_2]}
        \end{align*}
  \item $l_1 \not\flows L \land l_2 \flows L$:
        \begin{align*}
        &\  \el{E[\Lv\ l_1\ e_1\ \bind\ \lambda x.\Lv\ l_2\ e_2]}
           = \el{E}[\Lv\ l_1\ \hole\ \bind\ \lambda x.\Lv\ l_2\ \el{e_2}] \\
        \longrightarrow_L &\
           \el{\el{E}[\Lv\ (l_1\lub l_2)\ [\hole/x]\el{e_2}]}
           =  \el{E}[\Lv\ (l_1\lub l_2)\ \hole ]\\
        &\ =   \el{E}[\el{\Lv\ (l_1\lub l_2)\ \hole}]
           =   \el{E[\Lv\ (l_1\lub l_2)\ \hole]}
           =   \el{E[\Lv\ (l_1\lub l_2)\ [e_1/x]e_2]}
        \end{align*}
  \item $l_1 \flows L \land l_2 \not\flows L$:
        \begin{align*}
        &\  \el{E[\Lv\ l_1\ e_1\ \bind\ \lambda x.\Lv\ l_2\ e_2]}
           = \el{E}[\Lv\ l_1\ \el{e_1}\ \bind\ \lambda x.\Lv\ l_2\ \hole] \\
        \longrightarrow_L &\
           \el{\el{E}[\Lv\ (l_1\lub l_2)\ [\el{e_1}/x]\hole]}
           =  \el{E}[\Lv\ (l_1\lub l_2)\ \hole ]\\
        &\ =   \el{E}[\el{\Lv\ (l_1\lub l_2)\ \hole}]
           =   \el{E[\Lv\ (l_1\lub l_2)\ \hole]}
           =   \el{E[\Lv\ (l_1\lub l_2)\ [e_1/x]e_2]}
        \end{align*}
  \item $l_1 \not\flows L \land l_2 \not\flows L$:
        \begin{align*}
        &\  \el{E[\Lv\ l_1\ e_1\ \bind\ \lambda x.\Lv\ l_2\ e_2]}
           = \el{E}[\Lv\ l_1\ \hole\ \bind\ \lambda x.\Lv\ l_2\ \hole] \\
        \longrightarrow_L &\
           \el{\el{E}[\Lv\ (l_1\lub l_2)\ [\hole/x]\hole]}
           =  \el{E}[\Lv\ (l_1\lub l_2)\ \hole ]\\
        &\ =   \el{E}[\el{\Lv\ (l_1\lub l_2)\ \hole}]
           =   \el{E[\Lv\ (l_1\lub l_2)\ \hole]}
           =   \el{E[\Lv\ (l_1\lub l_2)\ [e_1/x]e_2]}
        \end{align*}
  \end{itemize}
%
\item Case: $\inferrule
                  {\labelOf{l_3} = \labelOf{ l_1 \lub l_2}}
                % --------------------------------------------
                {E[l_1\ \lub\ l_2] \longrightarrow E[l_3]}$:\\
  Follows from definition of $\el{\cdot}$ and
  Proposition~\ref{proposition:erase}.
%
\item Case: $\inferrule
                  {\labelOf{l_3} = \labelOf{ l_1 \glb l_2}}
                % --------------------------------------------
                {E[l_1\ \glb\ l_2] \longrightarrow E[l_3]}$:\\
  Follows from definition of $\el{\cdot}$ and
  Proposition~\ref{proposition:erase}.
%
\item Case: $\inferrule
      {\env[\lbl\mapsto l_1, \clr\mapsto l_2]\\ l_1\flows l_2}
      %----------------------------------------------------------------------
      {\langle \emptyset, E[\withLblClr\ (l_1, l_2)\ \lioValp{e}]\rangle
                      \longrightarrow \langle \env, E[\lioValp{e}]\rangle}$:
      \begin{align*}
      &\ \langle \emptyset, \el{E[\withLblClr\ (l_1,l_2)\ \lioValp{e}]}
         \rangle
       = \langle \emptyset,
         \el{E}[\withLblClr\ (l, c)\ \lioValp{\el{e}}]\rangle\\
      &\ \longrightarrow_L 
          \langle \env,  \el{\el{E}[\lioValp{\el{e}}]}\rangle
          =\langle \env,  \el{E}[\lioValp{\el{e}}]\rangle
          =\langle \env,  \el{E}[\el{\lioValp{e}}]\rangle
          =\langle \env,  \el{E[\lioValp{e}]} \rangle
      \end{align*}
%
\item Case: $\inferrule
                      {\env(\lbl) \flows l_1 \flows \env(\clr)}
      %----------------------------------------------------------------------
      {\langle \env, E[\seal\ l_1\ e]\rangle
            \longrightarrow \langle \env, E[\lioValp{\Lv\ l_1\ e}]\rangle}$:
      \begin{itemize}
          \item $l_1 \flows L$:
          \begin{align*}
                &\ \el{E[\seal\ l_1\ e]} = \el{E}[\seal\ l_1\ \el{e}]\\
                \longrightarrow_L &\ 
                \el{\el{E}[\lioValp{\Lv\ l_1\ \el{e}}]}
                = \el{E}[\lioValp{\Lv\ l_1\ \el{e}}]\\
                &\ = \el{E}[\el{\lioValp{\Lv\ l_1\ e}}]
                = \el{E[\lioValp{\Lv\ l_1\ e}]}
          \end{align*}
          \item $l_1 \not\flows L$:
          \begin{align*}
                &\ \el{E[\seal\ l_1\ e]} = \el{E}[\seal\ l_1\ \el{e}]\\
                \longrightarrow_L &\ 
                \el{\el{E}[\lioValp{\Lv\ l_1\ \el{e}}]}
                = \el{E}[\lioValp{\Lv\ l_1\ \hole}]\\
                &\ = \el{E}[\el{\lioValp{\Lv\ l_1\ \hole}}]
                = \el{E[\lioValp{\Lv\ l_1\ \hole}]}
                = \el{E[\lioValp{\Lv\ l_1\ e}]}
          \end{align*}
      \end{itemize}
%
\item Case: $\inferrule
              {l^\prime = \env(\lbl) \lub l_1 \\ l^\prime \flows \env(\clr)
                \\ \env^\prime = \env[\lbl \mapsto l^\prime]}
      % ------------------------------------------------------------------------
      {\langle \env, E[\open\ (\Lv\ l_1\ e_1)]\rangle
               \longrightarrow \langle \env^\prime, E[\lioValp{e_1}]\rangle}$:
      \begin{itemize}
          \item $l_1 \flows L$:
          \begin{align*}
                   &\ \langle \env, \el{E[\open\ (\Lv\ l_1\ e_1)]}\rangle
                    = \langle \env, \el{E}[\open\ (\Lv\ l_1\ \el{e_1})]\rangle\\
                   \longrightarrow_L &\ 
                    \langle \env^\prime, \el{\el{E}[\lioValp{\el{e_1}}]}\rangle
                    =\langle \env^\prime, \el{E}[\lioValp{\el{e_1}}]\rangle\\
                    &\ =\langle \env^\prime, \el{E}[\el{\lioValp{e_1}}]\rangle
                       =\langle \env^\prime, \el{E[\lioValp{e_1}]}\rangle
          \end{align*}
          \item $l_1 \not\flows L$:
          \begin{align*}
                   &\ \langle \env, \el{E[\open\ (\Lv\ l_1\ e_1)]}\rangle
                    = \langle \env, \el{E}[\open\ (\Lv\ l_1\ \hole)]\rangle\\
                   \longrightarrow_L &\ 
                    \langle \env^\prime, \el{\el{E}[\lioValp{\hole}]}\rangle
                    =\langle \env^\prime, \el{E}[\lioValp{\hole}]\rangle\\
                    &\ =\langle \env^\prime, \el{E}[\el{\lioValp{\hole}}]\rangle
                       =\langle \env^\prime, \el{E[\lioValp{\hole}]}\rangle
                       =\langle \env^\prime, \el{E[\lioValp{e_1}]}\rangle
          \end{align*}
      \end{itemize}
%
\item Case: $E[\returnLIOp\ e] \longrightarrow E[\lioValp{e}]$:\\
  Follows from definition of $\el{\cdot}$ and
  Proposition~\ref{proposition:erase}.
%
\item Case: $E[\lioValp{e_1}\ \bindLIOp\ \lambda x. e_2]
                \longrightarrow E[[e_1/x]e_2]$:\\
  Follows similarly.
%
\item Case: $E[\lioValp{e_1}\ \bindLIOp\ \lambda x. \returnLIOp\ x]
                  \longrightarrow E[\lioValp{e_1}]$:\\
  Follows similarly.
\end{enumerate}
\end{proof}

\begin{lemma}[Multi-step simulation wihout close]
\label{lemma:multi-step-noclose}
If $ \Gamma \vdash e : \tau$, $e$ does not contain any \close{} terms, and
${\langle \env, e \rangle
  \longrightarrow^* \langle \env^\prime, e^\prime\rangle}$
then 
$ \Gamma \vdash e^\prime : \tau$, and
${\langle \env, \erase{L}{e} \rangle
  \longrightarrow^*_L \langle \env^\prime, \erase{L}{e^\prime\rangle}}$.
\end{lemma}
\begin{proof}
By induction on Lemma~\ref{lemma:single-step-noclose}.
\end{proof}

\begin{lemma}[Single-step simulation of $\close$]
\label{lemma:single-step-close}
If $\Gamma \vdash e : \tau$, $e$ does not contain any \close{} terms, and
\begin{equation*}
\inferrule
             {\langle \env, \lioValp{e} \rangle \longrightarrow^*
                         \langle \env^\prime, \lioValp{v} \rangle
             \\ \env(\lbl) \flows \env^\prime(\lbl)
                             \flows \env^\prime(\clr) = \env(\clr)}
            % ------------------------------------------------------------------
      {\langle \env, E[\close\ \lioValp{e}]\rangle \longrightarrow
          \langle \env, E[\lioValp{\Lv\ \env^\prime(\lbl)\ v}] \rangle}
\end{equation*}
then 
$ \Gamma \vdash v : \tau$, and
\begin{equation*}
\inferrule
        {\langle \env, \el{\lioValp{e}} \rangle \longrightarrow_L^*
                \langle \env^\prime, \el{\lioValp{v}} \rangle 
        \\ \env(\lbl) \flows \env^\prime(\lbl)
                        \flows \env^\prime(\clr) = \env(\clr)}
      % --------------------------------------------------------------------
   {\langle \env, \el{E[\close\ \lioValp{e}]}\rangle \longrightarrow_L
      \langle \env, \el{E[\lioValp{\Lv\ \env^\prime(\lbl)\ v}]} \rangle}.
\end{equation*}
\end{lemma}
\begin{proof}
%
The premise directly follows from Lemma~\ref{lemma:multi-step-noclose}, it
remains for us to show:
\begin{equation*}
      \langle \env, \el{E[\close\ \lioValp{e}]}\rangle \longrightarrow_L
      \langle \env, \el{E[\lioValp{\Lv\ \env^\prime(\lbl)\ v}]} \rangle
\end{equation*}
for cases:
\begin{itemize}
\item $\env^\prime(\lbl) \flows L$:
\begin{align*}
   &\ \langle \env, \el{E[\close\ \lioValp{e}]}\rangle
   = \langle \env, \el{e}[\close\ \lioValp{\el{e}}]\rangle\\
   \longrightarrow_L &\ \langle \env,
               \el{\el{E}[\lioValp{\Lv\ \env^\prime(\lbl)\ \el{v}}]} \rangle
   =\langle \env, \el{E}[\lioValp{\Lv\ \env^\prime(\lbl)\ \el{v}}] \rangle\\
   &\ =\langle \env, \el{E[\lioValp{\Lv\ \env^\prime(\lbl)\ v}]} \rangle
\end{align*}

\item $\env^\prime(\lbl) \not\flows L$:
\begin{align*}
   &\ \langle \env, \el{E[\close\ \lioValp{e}]}\rangle
   = \langle \env, \el{e}[\close\ \lioValp{\el{e}}]\rangle\\
   \longrightarrow_L &\ \langle \env,
               \el{\el{E}[\lioValp{\Lv\ \env^\prime(\lbl)\ \el{v}}]} \rangle
   =\langle \env, \el{E}[\lioValp{\Lv\ \env^\prime(\lbl)\ \hole}] \rangle\\
   &\ =\langle \env, \el{E[\lioValp{\Lv\ \env^\prime(\lbl)\ \hole}]} \rangle
   =\langle \env, \el{E[\lioValp{\Lv\ \env^\prime(\lbl)\ v}]} \rangle
\end{align*}
\end{itemize}
\end{proof}

\begin{lemma}[Single-step simulation]
\label{lemma:single-step}
If $\Gamma \vdash e : \tau$, and
${\langle \env, e \rangle
       \longrightarrow \langle \env^\prime, e^\prime\rangle}$
then 
$ \Gamma \vdash e^\prime : \tau$, and
${\langle \env, \erase{L}{e} \rangle
       \longrightarrow_L \langle \env^\prime, \erase{L}{e^\prime\rangle}}$.
\end{lemma}
\begin{proof}
Follows directly from
Lemma~\ref{lemma:single-step-noclose},~\ref{lemma:multi-step-noclose},
and~\ref{lemma:single-step-close}.
\end{proof}

\begin{lemma}[Multi-step simulation]
\label{lemma:multi-step}
If $ \Gamma \vdash e : \tau$, and
${\langle \env, e \rangle
  \longrightarrow^* \langle \env^\prime, e^\prime\rangle}$
then 
$ \Gamma \vdash e^\prime : \tau$, and
${\langle \env, \erase{L}{e} \rangle
  \longrightarrow^*_L \langle \env^\prime, \erase{L}{e^\prime\rangle}}$.
\end{lemma}
\begin{proof}
By induction on Lemma~\ref{lemma:single-step}.
\end{proof}

\begin{definition}[$L$-equivalence]
Two labeled values, are equivalent according to the equivalence
relation $=_L$  if they agree on (labels and) values or if their
labeles are above $L$. Specifically, 
\begin{equation*}
\inferrule
  {(\Gamma \vdash e_j : \Lvalue\ {\ell}\ \tau)_{j=1,2}
  \\ (e_j\longrightarrow^* \Lv\ l_j\ v_j)_{j=1,2}
  \\ (l_j \not\flows L)_{j=1,2} \lor (l_1 = l_2 \land v_1=v_2)
  }
 %------------------------------------------------------------------------
                         {e_1 =_L e_2}
\end{equation*}
\end{definition}
%
\noindent The low-equivalence expresses the power of an observer, that may
distinguish values labeled with at most $L$.
For example, $\Lv\ \lH\ 8 =_\lL \Lv\ \lH\ 9$, but 
$\Lv\ \lL\ 2 \not =_{\lL} \Lv\ \lL\ 3$.
Similarly, if we extend the lattice with element
$\lM : \lL\flows \lM \flows \lH$, then
$\Lv\ \lH\ 8 =_\lL \Lv\ \lM\ 9$.


\begin{definition}[$L$-view]
Two values in environents $\env^1$ and $\env^2$, are equivalent according
to the equivalence relation $\approx_L$ if they are not observable,
or the pairs are $L$-equivalent.
Specifically, 
\begin{equation*}
\inferrule
  {(\Gamma \vdash e_j : \Lvalue\ {\ell}\ \tau)_{j=1,2} \\
  (\env^j(\lbl)\not\flows L)_{j=1,2}\lor (e_1=_L e_2)}
  % --------------------------------------------------------------------------
     {\langle \env^1, \lioValp{e_1} \rangle
                             \approx_L \langle \env^2, \lioValp{e_2}\rangle}
\end{equation*}
\end{definition}
%
\noindent The $L$-view equivalence directly extends the $L$-equivalance to
values in non-empty environments.
It states that an observer, who may read values with label at
most $L$, cannot distinguish two labeled values if they are either both in
an environment with a label above $L$, or the values are $L$-equivalent.
%

\begin{theorem}[Non-interference]
\label{theorem:non-interference}
Given label $l$,
a computation $e$ (with no $\hole$, $\Lv\ \cdot\ \cdot$,
or $\lioValp{\cdot}$) where
%
$\Gamma \vdash e : \Lvalue\ {\ell}\ \tau_i
                      \rightarrow \LIOp\ (\Lvalue\ {\ell}\ \tau_o)$
%
, environment with current label $l_\lE$ and current clearance $l_\lE^\prime$,
such that $l_\lE \flows l \flows l_\lE^\prime$, and
%
an observer with clearance $L$ such that
$l_\lE \flows L \flows l_\lE^\prime$ and $l \not\flows L$,
%
\begin{align*}
\forall e_1 e_2.
& (\Gamma \vdash e_j : \Lvalue\ \ell\ \tau_j)_{j=1,2} \\
%
&\land ( e_j = \Lv\ l\ e_j^\prime)_{j=1,2}\\
%
&\land
  \langle \emptyset, \withLblClr\ (l_\lE, l_\lE^\prime)\ (e\ e_1)\rangle
  \longrightarrow^*
  \langle \env^1, \lioValp{\Lv\ l_1\ v_1}\rangle\\
%
&\land
  \langle \emptyset, \withLblClr\ (l_\lE, l_\lE^\prime)\ (e\ e_2)\rangle
  \longrightarrow^*
  \langle \env^2, \lioValp{\Lv\ l_2\ v_2}\rangle\\
&\Rightarrow 
  \langle \env^1, \lioValp{\Lv\ l_1\ v_1}\rangle
  \approx_{L}
  \langle \env^2, \lioValp{\Lv\ l_2\ v_2}\rangle\\
\end{align*}
\end{theorem}

\noindent The theorem states that given two $L$-equivalent secret inputs,
the result of the computations as viewed by the observer (with clearance level
up to $L$) are indistinguishable. In other words, there is not information flow
from the secret input to the low-observed output.

\begin{proof}
We prove the lemma for the case where the input and output 
types are not labeled values of labeled values, i.e.,
$\tau_i \neq \Lvalue\ \ell\ \tau_i^\second,
\tau_o \neq \Lvalue\ \ell\ \tau_o^\prime$.
Extending it to this case is straight forward.
From Lemma~\ref{lemma:multi-step}, for $j=1,2$, we have
\begin{equation*}
\langle \emptyset, \el{\withLblClr\ (l_\lE, l_\lE^\prime)\
      (e\ (\Lv\ l\ e_j))} \rangle
= \langle \emptyset, \withLblClr\ (l_\lE, l_\lE^\prime)\
      (\el{e}\ (\Lv\ l\ \hole))\rangle
\longrightarrow^*_L
\langle \env^j, \el{\lioValp{\Lv\ l_j\ v_j}}\rangle
\end{equation*}
From the determinacy of $\longrightarrow_L$, given in
Proposition~\ref{proposition:determinacy-evalL},
the end environments and terms are equivalent, i.e.,
$\env^1\cong\env^2$, and
$\el{\lioValp{\Lv\ l_1\ v_1}}=\el{\lioValp{\Lv\ l_2\ v_2}}$.
Hence, we have cases:
\begin{enumerate}
\item For both $l_j\flows L$ and $l_j \not\flows L$, but
$\env^j(\lbl) \not\flows L$,
$\langle \env^1, \el{\lioValp{\hole}}\rangle
\approx_{L}
\langle \env^2, \el{\lioValp{\hole}}\rangle$
follows from 
$\env^1\cong\env^2$ and definition of~$\approx_{L}$.
%
\item Similarly, for $l_j\not\flows L$ and $\env^j(\lbl) \flows L$,
$\langle \env^1, \el{\lioValp{\Lv\ l_1\ \hole}}\rangle
\approx_{L}
\langle \env^2, \el{\lioValp{\Lv\ l_2\ \hole}}\rangle$
follows from
$\env^1\cong\env^2, l_1=l_2$ and definition of~$\approx_{L}$.
%
\item For $l_j\not\flows L$ and $\env^j(\lbl) \flows L$,
$\langle \env^1, {\lioValp{\Lv\ l_1\ v_1}}\rangle
\approx_{L}
\langle \env^2, {\lioValp{\Lv\ l_2\ v_2}}\rangle$
follows from
$\env^1\cong\env^2, l_1=l_2, v_1=v_2$
and definition of~$\approx_{L}$.
\end{enumerate}
\end{proof}

\begin{corollary}[Non-interference for differently labeld inputs]
Given labels $l_j, j=1,2$,
a computation $e$ (with no $\hole$, $\Lv\ \cdot\ \cdot$,
or $\lioValp{\cdot}$) where
%
$\Gamma \vdash e : \Lvalue\ {\ell}\ \tau_i
                      \rightarrow \LIOp\ (\Lvalue\ {\ell}\ \tau_o)$
%
, environment with current label $l_\lE$ and current clearance $l_\lE^\prime$,
such that $l_\lE \flows l_j \flows l_\lE^\prime$ for $j=1,2$, and
%
an observer with clearance $L$ such that
$l_\lE \flows L \flows l_\lE^\prime$ and $l_j \not\flows L$ for $j=1,2$,
%
\begin{align*}
\forall e_1 e_2.
& (\Gamma \vdash e_j : \Lvalue\ \ell\ \tau_j)_{j=1,2} \\
%
&\land ( e_j = \Lv\ l_j\ e_j^\prime)_{j=1,2}\\
%
&\land
  \langle \emptyset, \withLblClr\ (l_\lE, l_\lE^\prime)\ (e\ e_1)\rangle
  \longrightarrow^*
  \langle \env^1, \lioValp{\Lv\ l_1^\prime\ v_1}\rangle\\
%
&\land
  \langle \emptyset, \withLblClr\ (l_\lE, l_\lE^\prime)\ (e\ e_2)\rangle
  \longrightarrow^*
  \langle \env^2, \lioValp{\Lv\ l_2^\prime\ v_2}\rangle\\
&\Rightarrow 
  \langle \env^1, \lioValp{\Lv\ l_1^\prime\ v_1}\rangle
  \approx_{L}
  \langle \env^2, \lioValp{\Lv\ l_2^\prime\ v_2}\rangle\\
\end{align*}
\end{corollary}
\begin{proof}
Directly from Theorem~\ref{theorem:non-interference} with $l=l_1\lub l_2$.
\end{proof}





\end{document} 
