\documentclass[10pt]{article} 
\usepackage[margin=1in]{geometry} 
\usepackage{float}
\usepackage{amsmath,amssymb,amsfonts,amsthm,stmaryrd,txfonts, mathabx}
\usepackage{float}
\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage[usenames,dvipsnames]{color}
\newcommand{\Red}[1]{{\color{red} #1}}
\pagestyle{empty}

\date{\today}
 
\newcommand{\fix}{\texttt{fix}}
\newcommand{\lvalue}{\texttt{lvalue}}
\newcommand{\return}{\texttt{return}}
\newcommand{\bind}{\texttt{>>=}}
\newcommand{\seq}{\texttt{>>}}
\newcommand{\Lvalue}{\texttt{Lvalue}}
\newcommand{\Bool}{\texttt{Bool}}
\newcommand{\true}{\texttt{true}}
\newcommand{\false}{\texttt{false}}
\newcommand{\ifel}[3]{\texttt{if}\ #1\ \texttt{then}\ #2\ \texttt{else}\ #3}
\newcommand{\letbind}[3]{\texttt{let}\ #1=#2\ \texttt{in}\ #3}
\newcommand{\Lv}{\texttt{Lv}}
\newcommand{\flows}{\sqsubseteq^\ell}
\newcommand{\lub}{\sqcup^\ell}
\newcommand{\glb}{\sqcap^\ell}
\newcommand{\lpure}{l_\bot^\ell}
\newcommand{\labelOf}[1]{\mathcal{L} \llbracket #1 \rrbracket}
\newcommand{\lL}{\texttt{L}}
\newcommand{\lM}{\texttt{M}}
\newcommand{\lH}{\texttt{H}}
\newcommand{\Adv}{\mathcal{A}}
\newcommand{\seal}{\texttt{seal}}
\newcommand{\open}{\texttt{open}}
\newcommand{\close}{\texttt{close}}
\newcommand{\nolabel}{\obslash}
\newcommand{\unit}{\texttt{()}}
\newcommand{\getS}{\texttt{get}}
\newcommand{\putS}{\texttt{put}}
\newcommand{\evalLIO}{\texttt{evalLIO}}
%\newcommand{\evalrel}[4]{{}^_{#1}^{#2}{\longrightarrow}_{#3}^{#4}\ } %#3\xrightarrow[{#1 \quad #3}]{{#2 \quad #4}}}
\newcommand{\evalrel}[4]{\xrightarrow[{#1 \quad #3}]{{#2 \quad #4}}}
\newcommand{\transevalrel}[4]{{\xrightarrow[{#1 \quad #3}]{{#2 \quad #4}}}^{*}}

\newcommand{\LIO}{\texttt{LIO}}
\newcommand{\LIOp}{\texttt{LIO$^\prime$}} %$^\prime\ell$}}
\newcommand{\IO}{\texttt{IO}}
\newcommand{\returnLIOp}{\texttt{return}^\texttt{\tiny LIO$^\prime$}}
\newcommand{\bindLIOp}{\texttt{>>=}^\texttt{\tiny LIO$^\prime$}}
\newcommand{\seqLIO}{\texttt{>>}^\texttt{\tiny LIO$^\prime$}}
\newcommand{\lioValp}[1]{(#1)^\texttt{\tiny LIO$^\prime$}}

\newcommand{\tref}[1]{\textrm{#1}}

\newcommand{\withLblClr}{\texttt{withLblClr}}
\newcommand{\store}{\Delta_\ell}
\newcommand{\lbl}{\texttt{lbl}}
\newcommand{\clr}{\texttt{clr}}

\newcommand{\well}[2]{\mathcal{W}\llbracket #1,  #2 \rrbracket}
\newcommand{\tT}{\mathbb{T}}
\newcommand{\tF}{\mathbb{F}}

\newcommand{\hole}{\bullet}
\newcommand{\erase}[2]{\varepsilon_{#1}(#2)}
\newcommand{\el}[1]{\erase{L}{#1}}

\floatstyle{ruled}
\newfloat{typerules}{htbp}{lop} \floatname{typerules}{Typing Rule}
\newfloat{sos}{htbp}{lop} \floatname{sos}{Operational Semantics}
\newfloat{language}{htbp}{lop} \floatname{language}{Language}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{proposition}{Proposition}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\theoremstyle{remark}
\newtheorem{proofidea}{Proof idea}

\begin{document} 
\begin{enumerate}
\item
The typing relation has the standard form $\Gamma \vdash e : \tau$, which
can be read as ``term $e$ has type $\tau$ in the typing context $\Gamma$'';
$\Gamma$ is the set of assumptions on the types of the free variables in term
$e$.
Hence, $\Gamma : \textrm{Term} \rightarrow \textrm{Type}$.

\item
The function $\mathcal{L} : \textrm{Label} \rightarrow \mathsf{L}$ maps
labels to elements of lattice $\mathbb{L}$, i.e.,
$\labelOf{l} \in \mathsf{L}\cup\{\bot,\top\}$.
We use the meta-variables $l$ to denote Label values of type $\ell$.

The label type ($\ell$) and lattice may be arbitrary defined as long as
$\mathcal{L}$ is bijective.
However, we require that every label kind provide a default label for pure
values, denoted by $\lpure$ such that 
$\labelOf{\lpure} \in \mathsf{L}\cup\{\bot,\top\}$, and binary operators
$\lub, \glb, \flows$.
We highlight that $\mathcal{L}$ is homomorphically defined over label operations
$op \in \{\lub, \glb, \flows\}$, so
$\labelOf{l_1\ op\ l_2} = \labelOf{l_1}\ op\ \labelOf{l_2}$.


We overload operator $\flows$ to allow for comparison of syntactic labels in
the premise of evaluation rules. For example, $l_1 \flows l_2$ can be 
is has the semantic meaning of $\labelOf{l_1} \flows \labelOf{l_2}$.

\item
The evaluation contexts $E$ are terms with a hole; where $E[e]$ is a term
with the hole being replaced by $e$.
It is important to note that, for a unique $E$,
\begin{equation*}
\inferrule{e\longrightarrow e^\prime}{E[e]\longrightarrow E[e^\prime]}
\end{equation*}

\item
We use the notion of an environment
$\store : \{\lbl, \clr\} \rightarrow \textrm{Label}$ that maps
the {\em current label}, \lbl{}, and {\em current clearance}, \clr{}, to a
label value.
The current label is effectively a ceiling over the labels of all data the
current computation may depend on, the current clearance specified an upper
bound on permissible values of the current label.
This suggests that all data within the computation is uniformly
labeled by the current label. We provide labeled values ($\Lv{}\ l\ v$) to allow
for values ($v$) to be protected by labels ($l$) other than the current label.


The function \withLblClr{} is used to initialize $\store{}$, which may be
updated with functions such as \open{}.
In the actual implementation, we use a state transformer monad to
``thread'' the current label and clearance over the computation.
Our semantics assume the ability to modify and query the environment, which
we do not model explicitly:
we can avoid this layer of implementation detail as it provides no
interesting properties. Hence, our semantics are akin to modular monadic
semantics.

\item
Side-effects of certain functions may modify the environment $\store$.
The evaluation relation that may have side-effects in the environment is
\begin{equation*}
\inferrule{e\longrightarrow e^\prime}
{\langle \store, e\rangle \longrightarrow \langle \store^\prime, e^\prime\rangle}
\end{equation*}
which may be read as ``term $e$ in environment $\store$ evaluates to
$e^\prime$ in environment $\store^\prime$''.


\item
We define a wrapper type, \LIOp{}, the constructor of which is used to
wrap/box values $v$ into $\lioValp{v}$. \LIOp{} is a monad, for which we 
limit the operations to return and bind.
\Red{Do we need to parametrize \LIOp{} with $\ell$?}

\item
We say that a term is {\em stuck} at run-time if it violates information
flow control.

\item
For the ongoing examples we assume the following lattice elements:
$\{\lL, \lH\}$ with partial order $\bot \flows \lL \flows \lH \flows \top$,
and $\cdot \lub \lH = \lH$ and $\cdot \glb \lL = \lL$.
Additionally, we let $\lpure = \lL$.
For simplicity, we refer to \lL{} as the ``public label'' and
\lH{} as the ``secret label''. We assume the language supports
integer types and integer operations, e.g., addition.
\end{enumerate}

\begin{language}
\begin{align*}
\textrm{Lattice:} && \mathbb{L}&= (\mathsf{L}, \flows, \lub, \glb, \bot, \top)\\
\\
\textrm{Label:}   && l  &\\
\\
\textrm{Value:}   && v    &\Coloneqq   x                    % variable
                           \ |\  \lambda x.e                % abstraction
                           \ |\  (v, v)                     % tuple
                           \ |\  \Lv\ v\ v                  % val of type Lvalue
                           \ |\  \lioValp{v}                % value of type LIO'
                           \ |\  \true                      % value of type Bool
                           \ |\  \false                     % value of type Bool
                           \ |\  l                          % label
                           \ |\  \fix\ e                 \\ % recursion
\\
\textrm{Term:}    && e    &\Coloneqq  x                     % values
                           \ |\  \lambda x.e                % abstraction
                           \ |\  (e, e)                     % tuple
                           \ |\  \Lv\ e\ e                  % val of type Lvalue
                           \ |\  \lioValp{e}                % value of type LIO'
                           \ |\  \true                      % value of type Bool
                           \ |\  \false                     % value of type Bool
                           \ |\  l                          % label
                           \ |\  \fix\ e                 \\ % recursion
                  &&      &\ |\  e\ e                       % application
                           \ |\  \ifel{e}{e}{e}             % recursion
                           \ |\  \letbind{x}{e}{e}          % let-bindings
                           \ |\  \pi_i\ e                \\ % pi_1=fst,pi_2=snd
                  &&      &\ |\  \return\ e                 % return
                           \ |\  e\ \bind\ e             \\ % bind two exprs
                  &&      &\ |\  \withLblClr\ e\ e          % withLblClr
                           \ |\  \seal\ e\ e                % seal
                           \ |\  \open\ e                   % open
                           \ |\  \close\ e               \\ % close
                  &&      &\ |\  \returnLIOp\ e\            % returnLIOp
                           \ |\  e\ \bindLIOp\ e         \\ % bind two exprs
                  &&      &\ |\  e\ \lub\ e                 % lub
                           \ |\  e\ \glb\ e              \\ % glb
\\
\textrm{Type:}    && \tau &\Coloneqq  \tau\rightarrow\tau   % function
                           \ |\  (\tau,\tau)                % tuple
                           \ |\  \Bool                      % bool
                           \ |\  \ell                       % Label
                           \ |\  \Lvalue\ \tau_1\ \tau_2    % Lvalue
                           \ |\  \LIOp\ \tau             \\ % LIO'
\\
\textrm{Program:} && p    &\Coloneqq  (\letbind{x}{e}{})^*(\withLblClr\ e\ e)\\
\\
\textrm{Environment:} && \store & : \{\lbl,\clr\} \rightarrow \textrm{Label}
\end{align*}
\caption{Haskell embedded information flow control language. $\Lv\ e\ e$ is the
runtime representation of a labeled value and it does not appear in the source.
Similarly $\lioValp{e}$ is the runtime representation of a \LIOp{} value.}
\label{language:lvalue}
\end{language}

\begin{typerules}
\begin{align}
\inferrule{\Gamma(x)=\tau} 
     {\Gamma \vdash x : \tau}\tag{T-Var}
\\
\inferrule{\Gamma[x \mapsto \tau_1] \vdash e : \tau_2} 
     {\Gamma \vdash \lambda x.e : \tau_1 \rightarrow \tau_2}\tag{T-Abs}
\\
\inferrule{\Gamma \vdash e_1 : \tau_1 \\ \Gamma \vdash e_2 : \tau_2 }
     {\Gamma \vdash (e_1,e_2) : (\tau_1, \tau_2)}\tag{T-Tup}
\\
\inferrule{\Gamma \vdash e_1 : \ell \\ \Gamma \vdash e_2 : \tau}
     {\Gamma \vdash \Lv\ e_1\ e_2 : \Lvalue\ \ell\ \tau}\tag{T-Lv}
\\
\inferrule{}{\vdash \true : \Bool}\tag{T-True}
\\
\inferrule{}{\vdash \false : \Bool}\tag{T-False}
\\
\inferrule{}{\vdash l : \ell}\tag{T-Label}
\\
\inferrule{\Gamma \vdash e : \tau \rightarrow \tau}
     {\Gamma \vdash \fix\ e : \tau}\tag{T-Fix}
\\
\inferrule
{\Gamma \vdash e_1 : \tau_1 \rightarrow \tau_2 \\ \Gamma \vdash e_2 : \tau_1}
{\Gamma \vdash e_1\ e_2 : \tau_2}\tag{T-App}
\\
\inferrule
{\Gamma \vdash e_1 : \Bool \\ \Gamma \vdash e_2 : \tau
                           \\ \Gamma \vdash e_3 : \tau}
{\Gamma \vdash \ifel{e_1}{e_2}{e_3} : \tau}\tag{T-IfEl}
\\
\inferrule
{\Gamma \vdash e_1 : \tau_1 \\ \Gamma [x \mapsto \tau_1] \vdash e_2 : \tau_2}
{\Gamma \vdash \letbind{x}{e_1}{e_2} : \tau_2}\tag{T-Let}
\\
\inferrule{\Gamma \vdash e : (\tau_1, \tau_2)}
     {\Gamma \vdash \pi_i\ e : \tau_i}
     {(i\in\{1,2\})}\tag{T-Proj}
\\
\inferrule{\Gamma \vdash e : \tau}
     {\Gamma \vdash \return\ e : \Lvalue\ \ell\ \tau}\tag{T-Ret}
\\
\inferrule
{\Gamma \vdash e_1 : \Lvalue\ \ell\ \tau_1
 \\ \Gamma \vdash e_2 : \tau_1 \rightarrow \Lvalue\ \ell\ \tau_2}
{\Gamma \vdash e_1\ \bind\ e_2 : \Lvalue\ \ell\ \tau_2}\tag{T-Bind}
\\
\inferrule{\Gamma \vdash e_1 : \ell\\ \Gamma \vdash e_2 : \ell}
     {\Gamma \vdash e_1\ \lub\ e_2 : \ell}\tag{T-Join}
\\
\inferrule{\Gamma \vdash e_1 : \ell\\ \Gamma \vdash e_2 : \ell}
     {\Gamma \vdash e_1\ \glb\ e_2 : \ell}\tag{T-Meet}
\end{align}
\caption{Type rules for pure terms. The monadic return and bind are only
defined for type \Lvalue{}.}
\end{typerules}

\begin{typerules}
\begin{align}
\inferrule{\Gamma \vdash e : \tau}
     {\Gamma \vdash \lioValp{e} : \LIOp\ \tau}\tag{T-LIO$^\prime$-Val}
\\
\inferrule{\Gamma \vdash e_1 : (\ell,\ell) \\ \Gamma \vdash e_2 : \LIOp\ \tau}
     {\Gamma \vdash \withLblClr\ e_1\ e_2: \LIOp\ \tau}\tag{T-WithLblClr}
\\
\inferrule{\Gamma \vdash e_1 : \ell \\ \Gamma \vdash e_2 : \tau}
     {\Gamma \vdash \seal\ e_1\ e_2: \LIOp\ (\Lvalue\ \ell\ \tau)}\tag{T-Seal}
\\
\inferrule{\Gamma \vdash e : \Lvalue\ \ell\ \tau}
     {\Gamma \vdash \open\ e : \LIOp\ \tau}\tag{T-Open}
\\
\inferrule{\Gamma \vdash e : \LIOp\ \tau}
     {\Gamma \vdash \close\ e : \LIOp\ (\Lvalue\ \ell\ \tau)}\tag{T-Close}
\\
\inferrule{\Gamma \vdash e : \tau}
     {\Gamma \vdash \returnLIOp\ e  : \LIOp\ \tau}\tag{T-LIO$^\prime$-Ret}
\\
\inferrule
{\Gamma \vdash e_1 : \LIOp\ \tau_1
 \\ \Gamma \vdash e_2 : \tau_1 \rightarrow \LIOp\ \tau_2}
{\Gamma \vdash e_1\ \bindLIOp\ e_2 : \LIOp\ \tau_2}\tag{T-LIO$^\prime$-Bind}
\end{align}
\caption{Type rules for terms with side-effects. Monadic return and
bind are distinct from those of \Lvalue{}.}
\end{typerules}


\begin{sos}
\begin{align*}
&&E&   ::=  [\cdot]                    
       \ |\  E\ e                       
       \ |\  (E, e)                     
       \ |\  (v, E)                     
       \ |\  \Lv\ E\ e                    
       \ |\  \Lv\ v\ E                    
       \ |\  \ifel{E}{e}{e}
       \ |\  \letbind{x}{E}{e}
       \ |\  \pi_i\ E                     
       \\
&&&    \ |\  \return\ E                 
       \ |\  E\ \diamond\ e                
       \ |\  v\ \diamond\ E, \textrm{where }\diamond = \{\bind, \lub, \glb\}
       \\
\\
%
&&&E[(\lambda x.e_1)\ e_2] \longrightarrow E[[e_2/x]e_1] \tag{E-App}\\
%
&&&E[\fix\ e] \longrightarrow E[e\ (\fix\ e)] \tag{E-Fix}\\
%
&&&E[\ifel{\true}{e_1}{e_2}]  \longrightarrow E[e_1] \tag{E-IfTrue}\\
%
&&&E[\ifel{\false}{e_1}{e_2}] \longrightarrow E[e_2] \tag{E-IfFalse}\\
%
%&&&\inferrule
%                {e_1 \longrightarrow {e_1}^\prime}
%% --------------------------------------------------------------------------
%{E[\letbind{x}{e_1}{e_2}] \longrightarrow E[\letbind{x}{{e_1}^\prime}{e_2}]}
%\tag{E-Let}\\
%
%&&&E[\letbind{x}{v}{e}] \longrightarrow E[[v/x]e] \tag{E-Let}\\
%
%&&&E[\letbind{x}{v}{e}] \longrightarrow E[[v/x]e] \tag{E-Let}\\
&&&E[\letbind{x}{e_1}{e_2}] \longrightarrow E[[e_1/x]e] \tag{E-Let}\\
%
&&&E[\pi_i\ (e_1,e_2)] \longrightarrow E[e_i] \tag{E-Proj}\\
%
&&&E[\return\ e] \longrightarrow E[\Lv\ \lpure\ e] \tag{E-Ret}\\
%
&&&\inferrule
                        {e_2 \ne \Lv\ e_1^\prime\ e_2^\prime}
% --------------------------------------------------------------------------
{E[\Lv\ l_1\ e_1\ \bind\ \lambda x.e_2]
              \longrightarrow E[[e_1/x]e_2\ \bind\ \lambda x.\Lv\ l_1\ x]}
\tag{E-Bind}\\
%
&&&E[\Lv\ l_1\ e_1\ \bind\ \lambda x.\Lv\ l_2\ e_2]
        \longrightarrow E[\Lv\ (l_1\lub l_2)\ [e_1/x]e_2]\tag{E-RUnit}\\
%
&&&\inferrule
            {\labelOf{l_3} = \labelOf{l_1} \lub \labelOf{l_2}}
% --------------------------------------------------------------------------
            {E[l_1\ \lub\ l_2] \longrightarrow E[l_3]} \tag{E-Join}\\
%
&&&\inferrule
            {\labelOf{l_3} = \labelOf{l_1} \glb \labelOf{l_2}}
% --------------------------------------------------------------------------
           {E[l_1\ \glb\ l_2] \longrightarrow E[l_3]} \tag{E-Meet}
%
\end{align*}
\caption{Semantics for pure terms. These rewrite rules may be applied in 
any context.}
\label{sos:pure}
\end{sos}

\begin{sos}
\begin{align*}
&&E&   ::=  \cdots
       \ |\  \withLblClr\ E\ e
       \ |\  \seal\ E\ e
       \ |\  \seal\ v\ E
       \ |\  \open\ E                 
       \ |\  \close\ E                 
       \ |\  \returnLIOp\ E
       \ |\  E\ \bindLIOp\ e
       \ |\  v\ \bindLIOp\ E
       \ |\  \lioValp{E}
       \\
&&&
%
\inferrule
              {\store[\lbl\mapsto l_1, \clr\mapsto l_2]}
% --------------------------------------------------------------------------
{\langle \emptyset, E[\withLblClr\ (l_1, l_2)\ \lioValp{e}] \rangle
                        \longrightarrow \langle \store, E[\lioValp{e}]\rangle}
\tag{E-WithLblClr}\\
%
&&&\inferrule
             {\store(\lbl) \flows l_1 \flows \store(\clr)}
% --------------------------------------------------------------------------
{\langle \store, E[\seal\ l_1\ e]\rangle
            \longrightarrow \langle \store, E[\lioValp{\Lv\ l_1\ e}]\rangle}
\tag{E-LIO-Seal}\\
%
&&&\inferrule
{l^\prime = \store(\lbl) \lub l_1 \\ l^\prime \flows \store(\clr)
                           \\ \store^\prime = \store[\lbl \mapsto l^\prime]}
% --------------------------------------------------------------------------
{\langle \store, E[\open\ (\Lv\ l_1\ e_1)]\rangle
             \longrightarrow \langle \store^\prime, E[\lioValp{e_1}]\rangle}
\tag{E-LIO-Open} \\
%
&&&\inferrule
{\langle \store, \lioValp{e} \rangle
    \longrightarrow^* \langle \store^\prime, \lioValp{v} \rangle
\\ \store(\lbl) \flows \store^\prime(\lbl)
    \flows \store^\prime(\clr) \flows \store(\clr)
\\ l = \store^\prime(\lbl)}
% --------------------------------------------------------------------------
{\langle \store, E[\close\ \lioValp{e}]\rangle
  \longrightarrow \langle \store, E[\lioValp{\Lv\ l\ v}]\rangle}
\tag{E-LIO-Close} \\
%
\\
&&&E[\returnLIOp\ e] \longrightarrow E[\lioValp{e}] \tag{E-LIO$^\prime$-Ret}\\
%
&&&E[\lioValp{e_1}\ \bindLIOp\ \lambda x. e_2] \longrightarrow E[[e_1/x]e_2]
\tag{E-LIO$^\prime$-Bind}\\
%
&&&E[\lioValp{e_1}\ \bindLIOp\ \lambda x. \returnLIOp\ x]
           \longrightarrow E[\lioValp{e_1}] \tag{E-LIO$^\prime$-RUnit}
%
\end{align*}
\caption{Semantics for terms with side effects.}
\label{sos:sideeffect}
\end{sos}


\pagebreak


\begin{example}[Example with no side-effects]\label{ex:pure}
Let us consider a simple example, working only on pure terms. In this example
we are given two labeled values, one public, with a label \lL{}, and another,
secret, with label \lH. Adding the two we expect the resulting value to be
labeled \lH.

\begin{align*}
&                     && \fbox{\Lv\ \lL\ 1}\ \bind\ \lambda x.\
                         \Lv\ \lH\ 2\ \bind\ \lambda y.\
                         \return\ (x + y) \\
&\tref{E-Bind}:        & \longrightarrow &
                         \fbox{\Lv\ \lH\ 2}\ \bind\ \lambda y.
                         \return\ (1 + y)\
                         \bind\ \lambda x.\Lv\ \lL\ x\\
&\tref{E-Bind}:        & \longrightarrow &
                         \return\ \fbox{(1 + 2)}\
                         \bind\ \lambda x.\Lv\ \lL\ x
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-Add}:         & \longrightarrow &
                         \fbox{\return\ 3}\
                         \bind\ \lambda x.\Lv\ \lL\ x
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-Ret}:         & \longrightarrow &
                         \fbox{$\Lv\ \lpure\ 3$}\ 
                         \bind\ \lambda x.\Lv\ \lL\ x
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-RUnit}:       & \longrightarrow &
                         \Lv\ (\fbox{$\lpure\lub\lL$})\ 3\ 
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-Join}:        & \longrightarrow &
                         \fbox{\Lv\ \lL\ 3}\ 
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-RUnit}:       & \longrightarrow &
                         \Lv\ (\fbox{$\lL\lub\lH$})\ 3\\
&\tref{E-Join}:        & \longrightarrow &
                         \Lv\ \lH\ 3\\
\end{align*}
\end{example}

\begin{example}[Example with side-effects]\label{ex:sideeffect}
Let us consider a more complex example, a full program, that type checks and
does not violate the information flow constraints.
For simplicity, and since Example~\ref{ex:pure} is a special case of $f$, we
do not expand $f$.
\begin{align*}
&                     && {\tt let}\ f\ =\lambda x_l. \lambda y_l. x_l\ \bind\
                                        \lambda x. y_l\ \bind\
                                        \lambda y. \return\ (x + y)\\
&                     && {\tt in}\ \withLblClr\ (\lL, \lH)\ (\
                                \seal\ \lL\ 1\ \bindLIOp\ \lambda x.  
                                \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                \open\ (f\ x\ y)\ )\\
&\tref{E-Let}:        & \longrightarrow & \langle \emptyset,
                                          \fbox{$\withLblClr\ (\lL, \lH)\ (\
                                          \seal\ \lL\ 1\ \bindLIOp\ \lambda x.  
                                          \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ x\ y)\ )$}\rangle\\
&\tref{E-WithLblClr}: & \longrightarrow & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \fbox{\seal\ \lL\ 1}\ \bindLIOp\
                                          \lambda x.  
                                          \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ x\ y) \rangle\\
&\tref{E-LIO-Seal}:   & \longrightarrow & \langle \{(\lbl,\lL),(\clr,\lH)\}, 
                                          \fbox{$\lioValp{\Lv\ \lL\ 1}$}\
                                          \bindLIOp\
                                          \lambda x.  
                                          \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ x\ y) \rangle\\
&\tref{E-LIO$^\prime$-Bind}:
                      & \longrightarrow & \langle \{(\lbl,\lL),(\clr,\lH)\}, 
                                          \fbox{\seal\ \lH\ 2}\ \bindLIOp\
                                          \lambda y. 
                                          \open\ (f\ (\Lv\ \lL\ 1) \ y)\rangle\\
&\tref{E-LIO-Seal}:   & \longrightarrow & \langle \{(\lbl,\lL),(\clr,\lH)\}, 
                                          \fbox{$\lioValp{\Lv\ \lH\ 2}$}\
                                          \bindLIOp\
                                          \lambda y. 
                                          \open\ (f\ (\Lv\ \lL\ 1) \ y)\rangle\\
&\tref{E-LIO$^\prime$-Bind}:
                      & \longrightarrow & \langle \{(\lbl,\lL),(\clr,\lH)\}, 
                                          \open\ (\fbox{f\ (\Lv\ \lL\ 1)\
                                                     (\Lv\ \lH\ 2)}) \rangle\\
&\textrm{Evaluate $f$}:
                      & \longrightarrow^* & \langle \{(\lbl,\lL),(\clr,\lH)\}, 
                                          \fbox{\open\ (\Lv\ \lH\ 3)} \rangle\\
&\tref{E-LIO-Open}:   & \longrightarrow & \langle \{(\lbl,\lH),(\clr,\lH)\}, 
                                          \lioValp{3} \rangle\\
\end{align*}
\end{example}

\begin{example}[Example with side-effects and no label-raising]
Let us reconsider the above example using \close{} to prevent final current
label increase.
For simplicity, we do not repeat the steps shown in the previous example.
\begin{align*}
&                     && {\tt let}\ f\ =\lambda x_l. \lambda y_l. x_l\ \bind\ 
                                        \lambda x.  y_l\ \bind\
                                        \lambda y.  \return\ (x + y)\\
&                     && {\tt in}\ \withLblClr\ (\lL, \lH)\ (\ \close\ (
                                \seal\ \lL\ 1\ \bindLIOp\ \lambda x.  
                                \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                \open\ (f\ x\ y))\ )\\
&\tref{E-Let}:        & \longrightarrow & \langle \emptyset,\fbox{$
                                          \withLblClr\ (\lL, \lH)\ (\ \close\ (
                                          \seal\ \lL\ 1\ \bindLIOp\ \lambda x.  
                                          \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ x\ y))\ )$}\rangle\\
&\tref{E-WithLblClr}: & \longrightarrow & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \fbox{$\close\ (
                                            \seal\ \lL\ 1\ \bindLIOp\ \lambda x.
                                            \seal\ \lH\ 2\ \bindLIOp\ \lambda y.
                                            \open\ (f\ x\ y)
                                               )$} \rangle\\
&\tref{E-LIO-Close}:   & \longrightarrow &
\inferrule{\textrm{\footnotesize $
    \langle \{(\lbl,\lL),(\clr,\lH)\}, 
    \lioValp{\Lv\ \lL\ 1}\ \bindLIOp\ \lambda x.  
    \seal\ 2\ \lH\ \bindLIOp\ \lambda y. 
    \open\ (f\ x\ y) \rangle
    \longrightarrow^{*}
    \langle \{(\lbl,\lH),(\clr,\lH)\}, 
    \lioValp{3} \rangle$}}
    {\langle \{(\lbl,\lL),(\clr,\lH)\}, \lioValp{\Lv\ \lH\ 3}\rangle}
\end{align*}
\end{example}

\begin{example}[Example with side-effects that violates information flow]
As above, we consider a full program, but in this case one that would violates
information flow (flow from a secret value to a public value).
\begin{align*}
&                     && \langle \emptyset, \fbox{$\withLblClr\ (\lL, \lH)\ (\
                         \seal\ \lH\ 1\ \bindLIOp\ \lambda x.  
                         \open\ x\ \bindLIOp\ \lambda y. 
                         \seal\ \lL\ y)$}\rangle\\
&\tref{E-WithLblClr}: & \longrightarrow & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \fbox{$\seal\ \lH\ 1$}\
                                          \bindLIOp\ \lambda x.  
                                          \open\ x\ \bindLIOp\ \lambda y. 
                                          \seal\ \lL\ y)\rangle\\
&\tref{E-LIO-Seal}:   & \longrightarrow & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \fbox{$\lioValp{\Lv\ \lH\ 1}$}\
                                          \bindLIOp\
                                          \lambda x.  
                                          \open\ x\ \bindLIOp\ \lambda y. 
                                          \seal\ \lL\ y\rangle\\
&\tref{E-LIO$^\prime$-Bind}:
                      & \longrightarrow & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \open\ (\fbox{$\Lv\ \lH\ 1$})\
                                          \bindLIOp\
                                          \lambda y. 
                                          \seal\ \lL\ y\rangle\\
&\tref{E-LIO-Open}:   & \longrightarrow & \langle \{(\lbl,\lH),(\clr,\lH)\},
                                          \fbox{$\lioValp{1}$}\ \bindLIOp\
                                          \lambda y. 
                                          \seal\ \lL\ y\rangle\\
&\tref{E-LIO$^\prime$-Bind}:
                      & \longrightarrow & \langle \{(\lbl,\lH),(\clr,\lH)\},
                                          \fbox{$\seal\ \lL\ 1$}\rangle\\
&\tref{E-LIO-Seal}:   & \texttt{STUCK: }& \textrm{Premise for rule is not
                                               satisfied: $\lH \not\flows \lL$.}
\end{align*}
\end{example}







\subsection{Language properties}

\begin{definition}[Pure term]
A pure term $e$ does not depend on the environment and may take an evaluation
step regardless of whether the environment is empty or not. The semantics of
pure terms is given in Operational~Semantics~\ref{sos:pure}.
\end{definition}

\begin{proposition}[Determinacy of $(\longrightarrow)$]
\label{proposition:determinacy-eval}
\quad
\begin{itemize}
\item
For term $e$ there is a unique term $e^\prime$ and unique evaluation context
$E$: $e = E[e^\prime]$.
%
\item
If $e \longrightarrow\ e^\prime$ and $e \longrightarrow\ e^\second$
then $e^\prime = e^\second$.
\end{itemize}
\end{proposition}
\begin{proof}
By induction on terms and evaluation contexts.
\end{proof}



\begin{lemma}[Type preservation under information flow preservation]
\label{lemma:type-flow-preservation}
If $\vdash e : \tau$, and
$\langle \store, e\rangle \longrightarrow
  \langle \store^\prime, e^\prime \rangle$ then $\vdash e^\prime : \tau$.
\end{lemma}
\begin{proofidea}
Follows directly from the typing derivations.
\end{proofidea}
A well-typed term taking an evaluation step results in a term that is also
well-typed. Note that if a term takes an evaluation step, then it has not
violated information flow. Since information flow control rules are described
as premises to evaluation rules, an information flow violation results
in a term getting stuck. Note that this lemma encompasses the pure case
where $\store=\emptyset$.

Proving progress for the pure case, i.e., terms that do not depend on an 
environment is standard. However, the proof of progress for terms relying
on an environment, e.g., \seal{}, requires the definition of ``well-behaved''
terms. A term that does not violate the information flow control premises
of an evaluation rule is said to be well-behaved. At each step, a well-typed
and well-behaved term is either a value or it can progress.
Conversely, a well-typed but information flow violating term does not progress.


\subsection{Security properties}

The main security properties we are interested in are non-interference and
confinement. In formalizing and proving our security guarantees we introduce
a new syntactic term, `$\hole$', that denotes an ``erased'' term.
\begin{language}
\begin{align*}
&& e    &\Coloneqq  \cdots\ |\ \hole
\end{align*}
\caption{Extending language with erased terms}
\end{language}

Terms are then erased to a $\hole$ according to the label-dependent erasure
function $\erase{L}{e}$, that we define below:
\begin{align*}
\erase{L}{\hole} &= \hole\\
\erase{L}{x} &= x\\
\erase{L}{\lambda x. e} &= \lambda x.\erase{L}{e}\\
\erase{L}{\true} &= \true\\
\erase{L}{\false} &= \false\\
\erase{L}{l} &= l\\
\erase{L}{\fix\ e} &= \fix\ \erase{L}{e}\\
\\
\erase{L}{[\cdot]}&=[\cdot]\\
\erase{L}{E\ e} &= \erase{L}{E}\ \erase{L}{e}\\
\erase{L}{(E,e)}  &= (\erase{L}{E}, \erase{L}{e})\\
\erase{L}{(v,E)}  &= (\erase{L}{v}, \erase{L}{E})\\
\erase{L}{\Lv\ E\ e} &= \begin{cases}
                          \Lv\ \erase{L}{E}\ \hole & \erase{L}{E} \not\flows L\\
                          \Lv\ \erase{L}{E}\ \erase{L}{e} & \textrm{otherwise}\\
                        \end{cases}\\
\erase{L}{\Lv\ l\ E} &= \begin{cases}
                          \Lv\ l\ \hole &  l \not \flows L\\
                          \Lv\ l\ \erase{L}{E} & \textrm{otherwise}\\
                        \end{cases}\\
\erase{L}{\ifel{E}{e}} &= \ifel{\erase{L}{E}}{\erase{L}{e}}{\erase{L}{e}} \\
\erase{L}{\letbind{x}{E}{e}} &= \letbind{x}{\erase{L}{E}}{\erase{L}{e}} \\
\erase{L}{\pi_i\ E}  &= \pi_i\ \erase{L}{E}\\
\erase{L}{\return\ E}  &= \return\ \erase{L}{E}\\
\erase{L}{E\ \diamond\ e}  &= \erase{L}{E}\ \diamond\ \erase{L}{e}
                      \textrm{, where }\diamond = \{\bind, \lub, \glb\} \\
\\
\erase{L}{\withLblClr\ E\ e}&= \withLblClr\ \erase{L}{E}\ \erase{L}{e}\\
\erase{L}{\seal\ E\ e}          &= \seal\ \erase{L}{E}\ \erase{L}{e}\\
\erase{L}{\seal\ v\ E}          &= \seal\ \erase{L}{v}\ \erase{L}{E}\\
\erase{L}{\open\ E}             &= \open\ \erase{L}{E}\\
\erase{L}{\close\ E}             &= \close\ \erase{L}{E}\\
\erase{L}{\returnLIOp\ E} &= \returnLIOp\ \erase{L}{E}\\
\erase{L}{E\ \bindLIOp\ e}  &= \erase{L}{E}\ \bindLIOp\ \erase{L}{e}\\
\erase{L}{v\ \bindLIOp\ E}  &= \erase{L}{v}\ \bindLIOp\ \erase{L}{E}\\
\erase{L}{\lioValp{E}} &= \lioValp{\erase{L}{E}} \\
\end{align*}

Informally, to an observer reading labeled values with label at most $L$,
a computation $e$ is not distinguishable from $e^\prime$, where $e^\prime$ is 
$e$ with all values labeled above $L$ erased to $\hole$.
To prove our security guarantees we need to define a new evaluation relation, 
${\longrightarrow_L}$, that performs the term erasures. For pure terms,
%
\begin{equation*}
\inferrule{e \longrightarrow e^\prime}
          {e \longrightarrow_L \erase{L}{e^\prime}}
\end{equation*}
%
and, similarly, for terms in an environment,
%
\begin{equation*}
\inferrule
{\langle \store, e \rangle
            \longrightarrow \langle \store^\prime, e^\prime \rangle}
%-------------------------------------------------------------------------------
{\langle \store, e \rangle
           \longrightarrow_L \langle \store^\prime, \erase{L}{e^\prime} \rangle}
\end{equation*}

\begin{proposition}[Determinacy of $(\longrightarrow_L)$]
\label{proposition:determinacy-evalL}
\item
If $e \longrightarrow_L\ e^\prime$ and
$e \longrightarrow_L\ e^\second$ then $e^\prime = e^\second$.
\end{proposition}
\begin{proof}
From Proposition~\ref{proposition:determinacy-eval} and definition
of $\erase{L}{\cdot}$.
\end{proof}

\begin{example}[Example with term erasure on pure terms]
Let us consider Example~\ref{ex:pure}, working only on pure terms, and 
using the erasure function $\erase{\lL}{\cdot}$.
\begin{align*}
&                     && \fbox{\Lv\ \lL\ 1}\ \bind\ \lambda x.\
                         \Lv\ \lH\ 2\ \bind\ \lambda y.\
                         \return\ (x + y) \\
&\tref{E-Bind}:        & \longrightarrow_\lL\  &
                         \fbox{$\Lv\ \lH\ \hole$}\ \bind\ \lambda y.
                         \return\ (1 + y)\
                         \bind\ \lambda x.\Lv\ \lL\ x\\
&\tref{E-Bind}:        & \longrightarrow_\lL\  &
                         \return\ \fbox{$(1 + \hole)$}\
                         \bind\ \lambda x.\Lv\ \lL\ x
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-Add}:         & \longrightarrow_\lL\  &
                         \fbox{$\return\ \hole$}\
                         \bind\ \lambda x.\Lv\ \lL\ x
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-Ret}:         & \longrightarrow_\lL\  &
                         \fbox{$\Lv\ \lpure\ \hole$}\ 
                         \bind\ \lambda x.\Lv\ \lL\ x
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-RUnit}:       & \longrightarrow_\lL\  &
                         \Lv\ (\fbox{$\lpure\lub\lL$})\ \hole\ 
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-Join}:        & \longrightarrow_\lL\  &
                         \fbox{$\Lv\ \lL\ \hole$}\ 
                         \bind\ \lambda x.\Lv\ \lH\ x\\
&\tref{E-RUnit}:       & \longrightarrow_\lL\  &
                         \Lv\ (\fbox{$\lL\lub\lH$})\ \hole\\
&\tref{E-Join}:        & \longrightarrow_\lL\  &
                         \Lv\ \lH\ \hole\\
\end{align*}
\end{example}

\begin{example}[Example with term erasure on terms with side-effects]
Let us consider Example~\ref{ex:sideeffect}, working on terms with
side-effects, and using the erasure function $\erase{\lL}{\cdot}$.
\begin{align*}
&                     && {\tt let}\ f\ =\lambda x_l. \lambda y_l. x_l\ \bind\
                                        \lambda x. y_l\ \bind\
                                        \lambda y. \return\ (x + y)\\
&                     && {\tt in}\ \withLblClr\ (\lL, \lH)\ (\
                                \seal\ \lL\ 1\ \bindLIOp\ \lambda x.  
                                \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                \open\ (f\ x\ y)\ )\\
&\tref{E-Let}:        & \longrightarrow_\lL\  & \langle \emptyset,
                                          \fbox{$\withLblClr\ (\lL, \lH)\ (\
                                          \seal\ \lL\ 1\ \bindLIOp\ \lambda x.  
                                          \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ x\ y)\ )$}\rangle\\
&\tref{E-WithLblClr}: &\longrightarrow_\lL\ & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \fbox{\seal\ \lL\ 1}\ \bindLIOp\
                                          \lambda x.  
                                          \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ x\ y) \rangle\\
&\tref{E-LIO-Seal}:   &\longrightarrow_\lL\ & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \fbox{$\lioValp{\Lv\ \lL\ 1}$}\
                                          \bindLIOp\
                                          \lambda x.  
                                          \seal\ \lH\ 2\ \bindLIOp\ \lambda y. 
                                          \open\ (f\ x\ y) \rangle\\
&\tref{E-LIO$^\prime$-Bind}:
                      &\longrightarrow_\lL\ & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \fbox{\seal\ \lH\ 2}\ \bindLIOp\
                                          \lambda y. 
                                          \open\ (f\ (\Lv\ \lL\ 1) \ y)\rangle\\
&\tref{E-LIO-Seal}:   &\longrightarrow_\lL\ & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \fbox{$\lioValp{\Lv\ \lH\ \hole}$}\
                                          \bindLIOp\
                                          \lambda y. 
                                          \open\ (f\ (\Lv\ \lL\ 1) \ y)\rangle\\
&\tref{E-LIO$^\prime$-Bind}:
                      &\longrightarrow_\lL\ & \langle \{(\lbl,\lL),(\clr,\lH)\},
                                          \open\ (\fbox{$f\ (\Lv\ \lL\ 1)\
                                                 (\Lv\ \lH\ \hole)$}) \rangle\\
&\textrm{Evaluate $f$}:
                     &\longrightarrow_\lL^*\ &\langle \{(\lbl,\lL),(\clr,\lH)\},
                                     \fbox{$\open\ (\Lv\ \lH\ \hole)$} \rangle\\
&\tref{E-LIO-Open}:   &\longrightarrow_\lL\ & \langle \{(\lbl,\lH),(\clr,\lH)\},
                                          \lioValp{\hole} \rangle\\
\end{align*}
\end{example}

\begin{proposition}[Properties of $ \varepsilon_L $]\label{proposition:erase}
\quad
\begin{enumerate}
\item $\erase{L}{E[e]} = \erase{L}{E}[\erase{L}{e}]$
\item $\erase{L}{[e_2/x]e_1} = [\erase{L}{e_2}/x]\erase{L}{e_1}$
\item $\erase{L}{\erase{L}{e}} = \erase{L}{e}$
\item $\erase{L}{\erase{L}{E}} = \erase{L}{E}$
\item $\inferrule
              {\erase{L}{E}[e] \longrightarrow \erase{L}{E}[e^\prime] }
          % -------------------------------------------------------------------
          {\erase{L}{E}[e] \longrightarrow_L \erase{L}{E}[\erase{L}{e^\prime}] }
      $
\end{enumerate}
\end{proposition}
\begin{proof}
\quad
\begin{enumerate}
%
\item All follow directly from the induction on evaluation contexts and terms.
      We show several cases below.
  \begin{enumerate}
  \item Let $E := [\cdot]\ e_0$, it follows that
        $\erase{L}{E} := [\cdot]\ \erase{L}{e_0}$, and\\
        ${\erase{L}{E[e]}=\erase{L}{e\ e_0}=\erase{L}{e}\ \erase{L}{e_0}
                         =\erase{L}{E}[\erase{L}{e}]}$
  \item Let $E := ([\cdot], e_0)$, it follows that
        $\erase{L}{E} := ([\cdot], \erase{L}{e_0})$, and\\
        ${\erase{L}{E[e]}=\erase{L}{(e, e_0)}=(\erase{L}{e}, \erase{L}{e_0})
                         =\erase{L}{E}[\erase{L}{e}]}$
  \item $ E := (v, [\cdot])$ is as above.
  \item Let $ E := \Lv\ [\cdot]\ e_0$, it follows that 
        \begin{equation*}
         \erase{L}{E} := \begin{cases}
                      \Lv\ [\cdot]\ \hole &  [\cdot] \not \flows L\\
                      \Lv\ [\cdot]\ \erase{L}{e_0} & \textrm{otherwise}\\
                    \end{cases}
        \end{equation*}
        and
        \begin{equation*}
        \erase{L}{E[e]}=\erase{L}{\Lv\ e\ e_0}=
                              \begin{cases}
                                 \Lv\ e\ \hole &  e \not \flows L\\
                                 \Lv\ e\ \erase{L}{e_0} & \textrm{otherwise}\\
                              \end{cases},
        \end{equation*}
        from which $\erase{L}{E[e]} = \erase{L}{E}[\erase{L}{e}]$ follows
        directly.
  \item Let $ E := \Lv\ l\ [\cdot]$, it follows that 
        \begin{equation*}
         \erase{L}{E} := \begin{cases}
                      \Lv\ l\ \hole &  l \not \flows L\\
                      \Lv\ l\ \erase{L}{[\cdot]} & \textrm{otherwise}\\
                    \end{cases}
        \end{equation*}
        and
        \begin{equation*}
        \erase{L}{E[e]}=\erase{L}{\Lv\ l\ e}=
                            \begin{cases}
                               \Lv\ l\ \hole &  l \not \flows L\\
                               \Lv\ l\ \erase{L}{e} & \textrm{otherwise}\\
                            \end{cases},
        \end{equation*}
        from which $\erase{L}{E[e]} = \erase{L}{E}[\erase{L}{e}]$ follows
        directly.
  \end{enumerate}
%
\item $\erase{L}{[e_2/x]e_1} = \erase{L}{ (\lambda x . e_1)\ e_2}
       = \erase{L}{\lambda x . e_1}\ \erase{L}{e_2}
       = \lambda x . \erase{L}{e_1}\ \erase{L}{e_2}
       = [\erase{L}{e_2}/x]\erase{L}{e_1}
      $
%
\item Directly from definition of the erasure function and induction on terms.
%
\item Directly from definition of the erasure function and induction on terms
      and evaluation contexts.
%
\item From the property of evaluation contexts: 
  \begin{equation*}
  \inferrule{e \longrightarrow e^\prime}{E[e] \longrightarrow E[e^\prime]},
  \end{equation*}
  definition of $\longrightarrow_L$, and properties 2 and 4, above, we have 
  \begin{equation*}
  \inferrule
          {E[e] \longrightarrow E[e^\prime]}
    % --------------------------------------------
    {E[e] \longrightarrow_L \erase{L}{E[e^\prime]}}
  =\inferrule
               {E[e] \longrightarrow E[e^\prime]}
    % -------------------------------------------------------
    {E[e] \longrightarrow_L \erase{L}{E}[\erase{L}{e^\prime}]}
  =\inferrule
      {\erase{L}{E^\prime}[e] \longrightarrow \erase{L}{E^\prime}[e^\prime]}
    % ----------------------------------------------------------------------
    {\erase{L}{E^\prime}[e]
                \longrightarrow_L \erase{L}{E^\prime}[\erase{L}{e^\prime}] },
    \textrm{ for some $E=\erase{L}{E^\prime}$}.
  \end{equation*}
%
\end{enumerate}
\end{proof}


\begin{lemma}[Single-step simulation without close]
\label{lemma:single-step-noclose}
If $\Gamma \vdash e : \tau$, $e$ does not contain any \close{} terms, and
${\langle \store, e \rangle
       \longrightarrow \langle \store^\prime, e^\prime\rangle}$
then 
$ \Gamma \vdash e^\prime : \tau$, and
${\langle \store, \erase{L}{e} \rangle
       \longrightarrow_L \langle \store^\prime, \erase{L}{e^\prime\rangle}}$.
\end{lemma}
\begin{proof}
Lemma~\ref{lemma:type-flow-preservation} proves type preservation, so we limit
the proof to the simulation.
In most cases we do not show the environment in the simulation, for clarity.
\begin{enumerate}
\item Case: $E[(\lambda x. e_1)\ e_2] \longrightarrow  E[ [e_2/x]e_1]$:
  \begin{align*}
  &\ \el{E[(\lambda x. e_1)\ e_2]} = \el{E}[\el{(\lambda x. e_1)\ e_2}]
                                   = \el{E}[(\lambda x. \el{e_1})\ \el{e_2}]\\
  \longrightarrow_L &\  
   \el{\el{E}[{[\el{e_2}/x]\el{e_1}}]} =\el{\el{E}}[\el{[\el{e_2}/x]\el{e_1}}]
                                       =\el{E}[\el{[\el{e_2}/x]\el{e_1}}]\\ 
  &\ = \el{E}[{[\el{e_2}/x]\el{e_1}}]
     = \el{E}[\el{[e_2/x]e_1}]
     = \el{E[[e_2/x]e_1]} \textrm{ by Proposition~\ref{proposition:erase}.}
  \end{align*}
%
\item Case: $E[\fix\ e] \longrightarrow E[e (\fix\ e)]$:
  \begin{align*}
  &\ \el{E[\fix\ e]} = \el{E}[\el{\fix\ e}]= \el{E}[\fix\ \el{e}]\\
  \longrightarrow_L &\  
  \el{\el{E}[\el{e}\ (\fix\ \el{e})]}
  = \el{E}[\el{e}\ (\fix\ \el{e})]\\
  &\ = \el{E}[\el{e\ (\fix\ e)}]
  = \el{E[e\ (\fix\ e)]} \textrm{ by definition of $\el{\cdot}$ and
                                  Proposition~\ref{proposition:erase}.}
  \end{align*}
%
\item Case: $E[\ifel{\true}{e_1}{e_2}] \longrightarrow E[e_1]$: \\
  Follows similarly.
%
\item Case: $E[\ifel{\false}{e_1}{e_2}] \longrightarrow E[e_2]$: \\
  Follows similarly.
%
%\item Case: $\inferrule
%             {e_1 \longrightarrow {e_1}^\prime}
%  %-----------------------------------------------------------------------------
%  {E[\letbind{x}{e_1}{e_2}] \longrightarrow E[\letbind{x}{{e_1}^\prime}{e_2}]}$:
%  \\ Follows similarly.
%
\item Case: $E[\letbind{x}{e_1}{e_2}] \longrightarrow E[[e_1/x]e_2]$:\\
  Follows similarly.
%
\item Case: $E[\pi_i\ (e_1,e_2)]  \longrightarrow E[e_i]$:\\
  Follows similarly.
%
\item Case: $E[\return\ e]\longrightarrow E[\Lv\ \lpure\ e]$:
  \begin{itemize}
  \item $\lpure \flows L$:
        \begin{align*}
        &\ \el{E[\return\ e]}
        = \el{E}[\el{\return\ e}]
        = \el{E}[\return\ \el{e}]\\
        \longrightarrow_L &\  
        \el{\el{E}[\Lv\ \lpure\ \el{e}]}
        =\el{E}[\el{\Lv\ \lpure\ \el{e}}]
        =\el{E}[\Lv\ \lpure\ \el{e}]\\
        &\ =\el{E}[\el{\Lv\ \lpure\ e}]
           =\el{E[\Lv\ \lpure\ e]}
        \end{align*}
  \item $\lpure \not\flows L$:
        \begin{align*}
        &\ \el{E[\return\ e]}
        = \el{E}[\el{\return\ e}]
        = \el{E}[\return\ \el{e}]\\
        \longrightarrow_L &\  
        \el{\el{E}[\Lv\ \lpure\ \el{e}]}
        =\el{E}[\el{\Lv\ \lpure\ \el{e}}]
        =\el{E}[\Lv\ \lpure\ \hole]\\
        &\ =\el{E}[\el{\Lv\ \lpure\ \hole}]
           =\el{E[\Lv\ \lpure\ \hole]}
           =\el{E[\Lv\ \lpure\ e]}
        \end{align*}
  \end{itemize}
%
\item Case: $\inferrule
                      {e_2 \ne \Lv\ e_l\ e_2^\prime}
         % ------------------------------------------------------------
         {E[\Lv\ l_1\ e_1\ \bind\ \lambda x.e_2]
           \longrightarrow E[[e_1/x]e_2\ \bind\ \lambda x.\Lv\ l_1\ x]}$:
  \begin{itemize}
  \item $l_1 \flows L$:
        \begin{align*}
        &\ \el{E[\Lv\ l_1\ e_1\ \bind\ \lambda x.e_2]}
        = \el{E}[\el{\Lv\ l_1\ e_1\ \bind\ \lambda x.e_2}]
        = \el{E}[\Lv\ l_1\ \el{e_1}\ \bind\ \lambda x.\el{e_2}]\\
        \longrightarrow_L &\  
        \el{\el{E}[[\el{e_1}/x]\el{e_2}\ \bind\ \lambda x.\Lv\ l_1\ x]}
        = \el{E}[\el{[\el{e_1}/x]\el{e_2}\ \bind\ \lambda x.\Lv\ l_1\ x}]\\
        &\ = \el{E}[[\el{e_1}/x]\el{e_2}\ \bind\ \lambda x.\Lv\ l_1\ x]
           = \el{E}[\el{[e_1/x]e_2\ \bind\ \lambda x.\Lv\ l_1\ x}]\\
        &\ = \el{E[[e_1/x]e_2\ \bind\ \lambda x.\Lv\ l_1\ x]}
        \end{align*}
  \item $l_1 \not\flows L$:
        \begin{align*}
        &\ \el{E[\Lv\ l_1\ e_1\ \bind\ \lambda x.e_2]}
        = \el{E}[\el{\Lv\ l_1\ e_1\ \bind\ \lambda x.e_2}]
        = \el{E}[\Lv\ l_1\ \hole\ \bind\ \lambda x.\el{e_2}]\\
        \longrightarrow_L &\  
        \el{\el{E}[[\hole/x]\el{e_2}\ \bind\ \lambda x.\Lv\ l_1\ x]}
        = \el{E}[\el{[\hole/x]\el{e_2}\ \bind\ \lambda x.\Lv\ l_1\ x}]\\
        &\ = \el{E}[[\hole/x]\el{e_2}\ \bind\ \lambda x.\Lv\ l_1\ \hole]
           = \el{E}[\el{[\hole/x]e_2\ \bind\ \lambda x.\Lv\ l_1\ \hole}]\\
        &\ = \el{E[[\hole/x]e_2\ \bind\ \lambda x.\Lv\ l_1\ \hole]}
           = \el{E[[e_1/x]e_2\ \bind\ \lambda x.\Lv\ l_1\ x]}
        \end{align*}
  \end{itemize}
%
\item Case: $E[\Lv\ l_1\ e_1\ \bind\ \lambda x.\Lv\ l_2\ e_2]
                  \longrightarrow E[\Lv\ (l_1\lub l_2)\ [e_1/x]e_2]$:
  \begin{itemize}
  \item $l_1 \flows L \land l_2 \flows L$:
        \begin{align*}
        &\  \el{E[\Lv\ l_1\ e_1\ \bind\ \lambda x.\Lv\ l_2\ e_2]}
           = \el{E}[\Lv\ l_1\ \el{e_1}\ \bind\ \lambda x.\Lv\ l_2\ \el{e_2}] \\
        \longrightarrow_L &\
           \el{\el{E}[\Lv\ (l_1\lub l_2)\ [\el{e_1}/x]\el{e_2}]}
           =  \el{E}[\Lv\ (l_1\lub l_2)\ [\el{e_1}/x]\el{e_2}]\\
        &\ =   \el{E}[\el{\Lv\ (l_1\lub l_2)\ [e_1/x]e_2}]
           =   \el{E[\Lv\ (l_1\lub l_2)\ [e_1/x]e_2]}
        \end{align*}
  \item $l_1 \not\flows L \land l_2 \flows L$:
        \begin{align*}
        &\  \el{E[\Lv\ l_1\ e_1\ \bind\ \lambda x.\Lv\ l_2\ e_2]}
           = \el{E}[\Lv\ l_1\ \hole\ \bind\ \lambda x.\Lv\ l_2\ \el{e_2}] \\
        \longrightarrow_L &\
           \el{\el{E}[\Lv\ (l_1\lub l_2)\ [\hole/x]\el{e_2}]}
           =  \el{E}[\Lv\ (l_1\lub l_2)\ \hole ]\\
        &\ =   \el{E}[\el{\Lv\ (l_1\lub l_2)\ \hole}]
           =   \el{E[\Lv\ (l_1\lub l_2)\ \hole]}
           =   \el{E[\Lv\ (l_1\lub l_2)\ [e_1/x]e_2]}
        \end{align*}
  \item $l_1 \flows L \land l_2 \not\flows L$:
        \begin{align*}
        &\  \el{E[\Lv\ l_1\ e_1\ \bind\ \lambda x.\Lv\ l_2\ e_2]}
           = \el{E}[\Lv\ l_1\ \el{e_1}\ \bind\ \lambda x.\Lv\ l_2\ \hole] \\
        \longrightarrow_L &\
           \el{\el{E}[\Lv\ (l_1\lub l_2)\ [\el{e_1}/x]\hole]}
           =  \el{E}[\Lv\ (l_1\lub l_2)\ \hole ]\\
        &\ =   \el{E}[\el{\Lv\ (l_1\lub l_2)\ \hole}]
           =   \el{E[\Lv\ (l_1\lub l_2)\ \hole]}
           =   \el{E[\Lv\ (l_1\lub l_2)\ [e_1/x]e_2]}
        \end{align*}
  \item $l_1 \not\flows L \land l_2 \not\flows L$:
        \begin{align*}
        &\  \el{E[\Lv\ l_1\ e_1\ \bind\ \lambda x.\Lv\ l_2\ e_2]}
           = \el{E}[\Lv\ l_1\ \hole\ \bind\ \lambda x.\Lv\ l_2\ \hole] \\
        \longrightarrow_L &\
           \el{\el{E}[\Lv\ (l_1\lub l_2)\ [\hole/x]\hole]}
           =  \el{E}[\Lv\ (l_1\lub l_2)\ \hole ]\\
        &\ =   \el{E}[\el{\Lv\ (l_1\lub l_2)\ \hole}]
           =   \el{E[\Lv\ (l_1\lub l_2)\ \hole]}
           =   \el{E[\Lv\ (l_1\lub l_2)\ [e_1/x]e_2]}
        \end{align*}
  \end{itemize}
%
\item Case: $\inferrule
                  {\labelOf{l_3} = \labelOf{ l_1 \lub l_2}}
                % --------------------------------------------
                {E[l_1\ \lub\ l_2] \longrightarrow E[l_3]}$:\\
  Follows from definition of $\el{\cdot}$ and
  Proposition~\ref{proposition:erase}.
%
\item Case: $\inferrule
                  {\labelOf{l_3} = \labelOf{ l_1 \glb l_2}}
                % --------------------------------------------
                {E[l_1\ \glb\ l_2] \longrightarrow E[l_3]}$:\\
  Follows from definition of $\el{\cdot}$ and
  Proposition~\ref{proposition:erase}.
%
\item Case: $\inferrule
                      {\store[\lbl\mapsto l, \clr\mapsto c]}
      %----------------------------------------------------------------------
      {\langle \emptyset, \withLblClr\ (l, c)\ \lioValp{e} \rangle
                      \longrightarrow \langle \store,  \lioValp{e}\rangle}$:
      \begin{align*}
      &\ \langle \emptyset, \el{\withLblClr\ (l, c)\ \lioValp{e}} \rangle
       = \langle \emptyset, \withLblClr\ (l, c)\ \lioValp{\el{e}} \rangle\\
      &\ \longrightarrow_L  \langle \store,  \el{\lioValp{\el{e}}} \rangle
                        =\langle \store,  \lioValp{\el{e}} \rangle
                        =\langle \store,  \el{\lioValp{e}} \rangle
      \end{align*}
%
\item Case: $\inferrule
                      {\store(\lbl) \flows l_1 \flows \store(\clr)}
      %----------------------------------------------------------------------
      {\langle \store, E[\seal\ l_1\ e]\rangle
            \longrightarrow \langle \store, E[\lioValp{\Lv\ l_1\ e}]\rangle}$:
      \begin{itemize}
          \item $l_1 \flows L$:
          \begin{align*}
                &\ \el{E[\seal\ l_1\ e]} = \el{E}[\seal\ l_1\ \el{e}]\\
                \longrightarrow_L &\ 
                \el{\el{E}[\lioValp{\Lv\ l_1\ \el{e}}]}
                = \el{E}[\lioValp{\Lv\ l_1\ \el{e}}]\\
                &\ = \el{E}[\el{\lioValp{\Lv\ l_1\ e}}]
                = \el{E[\lioValp{\Lv\ l_1\ e}]}
          \end{align*}
          \item $l_1 \not\flows L$:
          \begin{align*}
                &\ \el{E[\seal\ l_1\ e]} = \el{E}[\seal\ l_1\ \el{e}]\\
                \longrightarrow_L &\ 
                \el{\el{E}[\lioValp{\Lv\ l_1\ \el{e}}]}
                = \el{E}[\lioValp{\Lv\ l_1\ \hole}]\\
                &\ = \el{E}[\el{\lioValp{\Lv\ l_1\ \hole}}]
                = \el{E[\lioValp{\Lv\ l_1\ \hole}]}
                = \el{E[\lioValp{\Lv\ l_1\ e}]}
          \end{align*}
      \end{itemize}
%
\item Case: $\inferrule
              {l^\prime = \store(\lbl) \lub l_1 \\ l^\prime \flows \store(\clr)
                \\ \store^\prime = \store[\lbl \mapsto l^\prime]}
      % ------------------------------------------------------------------------
      {\langle \store, E[\open\ (\Lv\ l_1\ e_1)]\rangle
               \longrightarrow \langle \store^\prime, E[\lioValp{e_1}]\rangle}$:
      \begin{itemize}
          \item $l_1 \flows L$:
          \begin{align*}
                   &\ \langle \store, \el{E[\open\ (\Lv\ l_1\ e_1)]}\rangle
                    = \langle \store, \el{E}[\open\ (\Lv\ l_1\ \el{e_1})]\rangle\\
                   \longrightarrow_L &\ 
                    \langle \store^\prime, \el{\el{E}[\lioValp{\el{e_1}}]}\rangle
                    =\langle \store^\prime, \el{E}[\lioValp{\el{e_1}}]\rangle\\
                    &\ =\langle \store^\prime, \el{E}[\el{\lioValp{e_1}}]\rangle
                       =\langle \store^\prime, \el{E[\lioValp{e_1}]}\rangle
          \end{align*}
          \item $l_1 \not\flows L$:
          \begin{align*}
                   &\ \langle \store, \el{E[\open\ (\Lv\ l_1\ e_1)]}\rangle
                    = \langle \store, \el{E}[\open\ (\Lv\ l_1\ \hole)]\rangle\\
                   \longrightarrow_L &\ 
                    \langle \store^\prime, \el{\el{E}[\lioValp{\hole}]}\rangle
                    =\langle \store^\prime, \el{E}[\lioValp{\hole}]\rangle\\
                    &\ =\langle \store^\prime, \el{E}[\el{\lioValp{\hole}}]\rangle
                       =\langle \store^\prime, \el{E[\lioValp{\hole}]}\rangle
                       =\langle \store^\prime, \el{E[\lioValp{e_1}]}\rangle
          \end{align*}
      \end{itemize}
%
\item Case: $E[\returnLIOp\ e] \longrightarrow E[\lioValp{e}]$:\\
  Follows from definition of $\el{\cdot}$ and
  Proposition~\ref{proposition:erase}.
%
\item Case: $E[\lioValp{e_1}\ \bindLIOp\ \lambda x. e_2]
                \longrightarrow E[[e_1/x]e_2]$:\\
  Follows similarly.
%
\item Case: $E[\lioValp{e_1}\ \bindLIOp\ \lambda x. \returnLIOp\ x]
                  \longrightarrow E[\lioValp{e_1}]$:\\
  Follows similarly.
\end{enumerate}
\end{proof}

\begin{lemma}[Multi-step simulation wihout close]
\label{lemma:multi-step-noclose}
If $ \Gamma \vdash e : \tau$, $e$ does not contain any \close{} terms, and
${\langle \store, e \rangle
  \longrightarrow^* \langle \store^\prime, e^\prime\rangle}$
then 
$ \Gamma \vdash e^\prime : \tau$, and
${\langle \store, \erase{L}{e} \rangle
  \longrightarrow^*_L \langle \store^\prime, \erase{L}{e^\prime\rangle}}$.
\end{lemma}
\begin{proof}
By induction on Lemma~\ref{lemma:single-step-noclose}.
\end{proof}

\begin{lemma}[Single-step simulation of $\close$]
\label{lemma:single-step-close}
If $\Gamma \vdash e : \tau$, $e$ does not contain any \close{} terms, and
\begin{equation*}
\inferrule
             {\langle \store, \lioValp{e} \rangle \longrightarrow^*
                         \langle \store^\prime, \lioValp{v} \rangle
             \\ \store(\lbl) \flows \store^\prime(\lbl)
                             \flows \store^\prime(\clr) = \store(\clr)}
            % ------------------------------------------------------------------
      {\langle \store, \close\ \lioValp{e}\rangle \longrightarrow
          \langle \store, \lioValp{\Lv\ \store^\prime(\lbl)\ v} \rangle}
\end{equation*}
then 
$ \Gamma \vdash v : \tau$, and
\begin{equation*}
\inferrule
        {\langle \store, \el{\lioValp{e}} \rangle \longrightarrow_L^*
                \langle \store^\prime, \el{\lioValp{v}} \rangle 
        \\ \store(\lbl) \flows \store^\prime(\lbl)
                        \flows \store^\prime(\clr) = \store(\clr)}
      % --------------------------------------------------------------------
   {\langle \store, \el{\close\ \lioValp{e}}\rangle \longrightarrow_L
      \langle \store, \el{\lioValp{\Lv\ \store^\prime(\lbl)\ v}} \rangle}.
\end{equation*}
\end{lemma}
\begin{proof}
%
The premise directly follows from Lemma~\ref{lemma:multi-step-noclose}, it
remains for us to show:
\begin{equation*}
      \langle \store, \el{\close\ \lioValp{e}}\rangle \longrightarrow_L
      \langle \store, \el{\lioValp{\Lv\ \store^\prime(\lbl)\ v}} \rangle
\end{equation*}
for cases:
\begin{itemize}
\item $\store^\prime(\lbl) \flows L$:
\begin{align*}
   &\ \langle \store, \el{\close\ \lioValp{e}}\rangle
   = \langle \store, \close\ \lioValp{\el{e}}\rangle\\
   \longrightarrow_L &\ \langle \store,
               \el{\lioValp{\Lv\ \store^\prime(\lbl)\ \el{v}}} \rangle
   =\langle \store, \lioValp{\Lv\ \store^\prime(\lbl)\ \el{v}} \rangle
   =\langle \store, \el{\lioValp{\Lv\ \store^\prime(\lbl)\ v}} \rangle
\end{align*}

\item $\store^\prime(\lbl) \not\flows L$:
\begin{align*}
   &\ \langle \store, \el{\close\ \lioValp{e}}\rangle
   = \langle \store, \close\ \lioValp{\el{e}}\rangle\\
   \longrightarrow_L &\ \langle \store,
               \el{\lioValp{\Lv\ \store^\prime(\lbl)\ \el{v}}} \rangle
   =\langle \store, \lioValp{\Lv\ \store^\prime(\lbl)\ \hole} \rangle\\
   &\ =\langle \store, \el{\lioValp{\Lv\ \store^\prime(\lbl)\ \hole}} \rangle
   =\langle \store, \el{\lioValp{\Lv\ \store^\prime(\lbl)\ v}} \rangle
\end{align*}
\end{itemize}
\end{proof}

\begin{lemma}[Single-step simulation]
\label{lemma:single-step}
If $\Gamma \vdash e : \tau$, and
${\langle \store, e \rangle
       \longrightarrow \langle \store^\prime, e^\prime\rangle}$
then 
$ \Gamma \vdash e^\prime : \tau$, and
${\langle \store, \erase{L}{e} \rangle
       \longrightarrow_L \langle \store^\prime, \erase{L}{e^\prime\rangle}}$.
\end{lemma}
\begin{proof}
Follows directly from
Lemma~\ref{lemma:single-step-noclose},~\ref{lemma:multi-step-noclose},
and~\ref{lemma:single-step-close}.
\end{proof}

\begin{lemma}[Multi-step simulation]
\label{lemma:multi-step}
If $ \Gamma \vdash e : \tau$, and
${\langle \store, e \rangle
  \longrightarrow^* \langle \store^\prime, e^\prime\rangle}$
then 
$ \Gamma \vdash e^\prime : \tau$, and
${\langle \store, \erase{L}{e} \rangle
  \longrightarrow^*_L \langle \store^\prime, \erase{L}{e^\prime\rangle}}$.
\end{lemma}
\begin{proof}
By induction on Lemma~\ref{lemma:single-step}.
\end{proof}


\pagebreak

\begin{definition}[$L$-equivalence]
Two values, each consisting of a pair of labeled values with labels
${l}, l_j, j=1,2$ such that $ l_j \not\flows{l}$,
are equivalent according to the equivalence
relation $=_L$  if they agree on the low values. Specifically, 
\begin{equation*}
\inferrule
  {\Gamma \vdash e_j :
          (\Lvalue\ {\ell}\ \tau^\prime, \Lvalue\ {\ell}\ \tau)\\
  e_j\longrightarrow^* (\Lv\ l_j\ v_j, \Lv\ l\ v)\\
  l \flows L\\ l_j \not\flows L}
 %------------------------------------------------------------------------
                         {e_1 =_L e_2}
  {(j=1,2)}
\end{equation*}
\Red{Does $\tau^\prime$ need to be the same type for both tuples, or can we
just have $\tau_j$?}
\end{definition}
%
The low-equivalence expresses the power of an observer, that may distinguish
values labeled with at most $L$.
For example, $(\Lv\ \lH\ 8,\Lv\ \lL\ 2) =_\lL (\Lv\ \lH\ 9,\Lv\ \lL\ 2)$, but 
$(\Lv\ \lH\ 8,\Lv\ \lL\ 2) \not =_{\lL} (\Lv\ \lH\ 8,\Lv\ \lL\ 3)$.
Similarly, if we extend the lattice with element
$\lM : \lL\flows \lM \flows \lH$, then
$(\Lv\ \lH\ 8,\Lv\ \lL\ 2) =_\lL (\Lv\ \lM\ 9,\Lv\ \lL\ 2)$.


\begin{definition}[$L$-view]
Two values (each consisting of a pair of labeled values) in environents
$\store^1$ and $\store^2$, are equivalent according to the equivalence relation
$\approx_L$ if they are not observable, i.e., $L$ is lower than
$\store^j(\lbl), j={1,2}$, or the pairs are $L$-equivalent. Specifically, 
\begin{equation*}
\inferrule
  {(\Gamma \vdash e_j :
          (\Lvalue\ {\ell}\ \tau^\prime, \Lvalue\ {\ell}\ \tau))_{j=1,2} \\
  (\store^1(\lbl)\not\flows L\land \store^2(\lbl)\not\flows L)\lor (e_1=_L e_2)}
  % --------------------------------------------------------------------------
     {\langle \store^1, \lioValp{e_1} \rangle
                             \approx_L \langle \store^2, \lioValp{e_2}\rangle}
\end{equation*}
\end{definition}
%
The $L$-view simply states that an observer, who may read values with label at
most $L$, cannot distinguish two labeled values if they are either 1) both in
an environment with a label above $L$, or 2) the values are $L$-equivalent.
%
For example,
\begin{align*}
\langle \{(\lbl,\lM),(\clr,\lH)\}, (\Lv\ \lH\ 8,\Lv\ \lL\ 2) \rangle
\approx_{\lL}
\langle \{(\lbl,\lH), (\clr,\lH)\}, (\Lv\ \lH\ 8,\Lv\ \lL\ 3)\rangle,
\end{align*}
even though the labeled pairs are not $L$-equivalent.
%
Similarly,
\begin{align*}
\langle \{(\lbl,\lM),(\clr,\lH)\}, (\Lv\ \lH\ 8,\Lv\ \lL\ 2) \rangle
\approx_\lM
\langle \{(\lbl,\lL),(\clr,\lH)\}, (\Lv\ \lH\ 9,\Lv\ \lL\ 2) \rangle,
\end{align*}
but
\begin{align*}
\langle \{(\lbl,\lL),(\clr,\lH)\}, (\Lv\ \lH\ 8,\Lv\ \lL\ 2) \rangle
\not \approx_\lL
\langle \{(\lbl,\lL),(\clr,\lH)\}, (\Lv\ \lH\ 8,\Lv\ \lL\ 3)
\rangle
\end{align*}



\begin{lemma}[Standard non-interference]
Given labels ${l}, {l}'$ such that $ {l}' \not\flows{l}$,
a computation $e$ (with no $\hole$, $\Lv\ \cdot\ \cdot$,
or $\lioValp{\cdot}$) where
%
$\Gamma \vdash e : (\Lvalue\ {\ell}\ \tau_i^\prime, \Lvalue\ {\ell}\ \tau_i)
\rightarrow \LIOp\ (\Lvalue\ {\ell}\ \tau_o^\prime, \Lvalue\ {\ell}\ \tau_o)$
%
in environment $\store$, such that $\store(\lbl)\flows l_k \flows \store(\clr)$
for $l_k = l,l'$,
%
and an observer with clearance $L$ such that
${l} \flows L$ and ${l}' \not\flows L$,
%
\begin{align*}
\forall e_1 e_2.
& (\Gamma \vdash e_j : (\Lvalue\ \ell\ \tau_i^\prime
                       ,\Lvalue\ \ell\ \tau_i))_{j=1,2}\\
%
&\land ( e_j = (\Lv\ l^\prime\ e_j^1, \Lv\ l\ e_j^2) )_{j=1,2}\\
%
&\land \withLblClr\ (\store(\lbl), \store(\clr))\ (e\ e_1) \longrightarrow^* \langle \store^\prime, \lioValp{(\Lv\ l^\prime\ v_1^1, \Lv\ l\ v_1^2)}\rangle\\
&\land \withLblClr\ (\store(\lbl), \store(\clr))\ (e\ e_2) \longrightarrow^* \langle \store^\prime, \lioValp{(\Lv\ l^\prime\ v_2^1, \Lv\ l\ v_2^2)}\rangle\\
&\Rightarrow 
\langle \store^\prime, \lioValp{(\Lv\ l^\prime\ v_1^1, \Lv\ l\ v_1^2)}\rangle \approx_{L}
\langle \store^\prime, \lioValp{(\Lv\ l^\prime\ v_2^1, \Lv\ l\ v_2^2)}\rangle\\
\end{align*}
\end{lemma}

Simply, the lemma states that given two $L$-equivalent inputs, each consisting of a pair of values with a public and secret labels, the result of the well-behaved computation as read by the observer (at label level up to $L$) is indistinguishable. In other words, there is not information flow from the high-labeled input to the low-labeled output.


\Red{
\begin{proof}

Using Lemma~\ref{lemma:multi-step},
\begin{equation*}
\el{\withLblClr\ (\store(\lbl), \store(\clr))\ (e\ (\Lv\ l^\prime\ e_j^1, \Lv\ l\ e_j^2))}
\longrightarrow^*_L \langle \store^\prime, \el{\lioValp{(\Lv\ l^\prime\ v_j^1, \Lv\ l\ v_j^2)}}\rangle
\end{equation*}
can be either 
\begin{enumerate}
\item
\begin{equation*}
\inferrule{\store^\prime{\lbl}=l \lor \store^\prime(\lbl) = \store(\lbl)}{\withLblClr\ (\store(\lbl), \store(\clr))\ (\el{e}\ (\Lv\ l^\prime\ \hole, \Lv\ l\ \el{e_j^2}))
\longrightarrow^*_L \langle \store^\prime, \lioValp{(\Lv\ l^\prime\ \hole, \Lv\ l\ \el{v_j^2})}\rangle}
\end{equation*}
\item
\begin{equation*}
\inferrule{\store^\second(\lbl) = l^\prime}{
\withLblClr\ (\store(\lbl), \store(\clr))\ (\el{e}\ (\Lv\ l^\prime\ \hole, \Lv\ l\ \el{e_j^2}))
\longrightarrow^*_L \langle \store^\second, \lioValp{\hole}\rangle}.
\end{equation*}
\end{enumerate}

If $\store^\second(\lbl) = l^\prime \not\flows L$, the $L$-view equivalence holds, by definition.
Otherwise, by Proposition~\ref{proposition:determinacy-evalL}, it must be that $v_1^2 = v_2^2$,
and consequently, $\langle \store, \lioValp{(\Lv\ l^\prime\ \hole, \Lv\ l\ v_1^2)}\rangle \approx_{L} \langle \store^\prime, \lioValp{(\Lv\ l^\prime\ \hole, \Lv\ l\ v_2^2)}\rangle$.
\end{proof}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
\section{OLD}
\subsection{Well-behaved terms}
We define a function ${\mathcal{W}\llbracket \rrbracket} : \textrm{Environment}\times\textrm{Term} \rightarrow \{\tT, \tF\}$, where $\tT{}$ denotes true, and $\tF{}$ denotes false.

\begin{align*}
\well{\store}{x} &= \tT\\
\well{\store}{\lambda x. e} &= \well{\store}{e}\\
\well{\store}{(e_1, e_2)} &= \well{\store}{e_1} \land \well{\store}{e_2}\\
%\well{\store}{\Lv\ l\ e} &= \well{\store}{e}\\
\well{\store}{\Lv\ e_1\ e_2} &= \well{\store}{e_1} \land \well{\store}{e_2}\\
\well{\store}{\lioValp{e}} &= \well{\store}{e}\\
\well{\store}{\true} &= \tT\\
\well{\store}{\false} &= \tT\\
\well{\store}{l} &= \tT\\
\well{\store}{\fix\ e} &= \well{\store}{e}\\
\well{\store}{e_1\ e_2} &= \well{\store}{e_1} \land \well{\store}{e_2}\\
%\well{\store}{\ifel{\true}{e_1}{e_2}} &= \well{\store}{e_1}\\
%\well{\store}{\ifel{\false}{e_1}{e_2}} &= \well{\store}{e_2}\\
\well{\store}{\ifel{e_1}{e_2}{e_3}} &= \well{\store}{e_1} \land \well{\store}{e_2} \land \well{\store}{e_3}\\
\well{\store}{\letbind{x}{e_1}{e_2}} &= \well{\store}{e_1} \land \well{\store}{e_2}\\
\well{\store}{\pi_i\ e} &= \well{\store}{e}\\
\well{\store}{\return\ e} &= \well{\store}{e}\\
\well{\store}{\returnLIOp\ e} &= \well{\store}{e}\\
\well{\store}{e_1\ \diamond\ e_2}  &= \well{\store}{e_1} \land \well{\store}{e_2}\textrm{, where }\diamond = \{\bind, \lub, \glb, \bindLIOp\} \\
\well{\store}{\withLblClr\ e_1\ e_2}  &= \well{\store}{e_1} \land \well{\store}{e_2}\\ %TODO: look over
\well{\store}{\seal\ e\ l}        &= (\store(\lbl) \flows l \flows \store(\clr)) \land\ \well{\store}{e}\\
\well{\store}{\open\ (\Lv\ l\ e)} &= (\store^\prime(\lbl) \flows \store(\clr)) \land \well{\store^\prime}{e},\\
                                      &\textrm{where } \store^\prime=\store[\lbl\mapsto l^\prime], \textrm{and } l^\prime = \store(\lbl)\lub l\\
\well{\store}{\close\ e} &= \well{\store}{e}
\end{align*}

We say that a term $e$ is well-behaved (at this point in the execution) in environment $\store$ if $\well{\store}{e}=\tT$.

\begin{proposition}[Properties of $\mathcal{W}$]\label{proposition:well-old}
\quad
\begin{enumerate}
\item IFC is not violated if environment constraints are relaxed:\\ 
  $\well{\store}{e} \land \store^\prime({\lbl}) \flows \store({\lbl}) \land  \store({\clr}) \flows \store^\prime({\clr}) \implies \well{\store^\prime}{e}$
\item Inversion of $\mathcal{W}$:
      \begin{enumerate}
        \item $\well{\store}{\lambda x. e} \implies \well{\store}{e}$
        \item $\well{\store}{(e_1, e_2)} \implies \well{\store}{e_1} \land \well{\store}{e_2}$
        \item $\well{\store}{\Lv\ e_1\ e_2} \implies \well{\store}{e_1} \land \well{\store}{e_2}$
        \item $\well{\store}{\lioValp{e}} \implies \well{\store}{e}$
        \item $\well{\store}{\fix\ e} \implies \well{\store}{e}$
        \item $\well{\store}{e_1\ e_2} \implies \well{\store}{e_1} \land \well{\store}{e_2}$
        \item $\well{\store}{\ifel{e_1}{e_2}{e_3}} \implies \well{\store}{e_1} \land \well{\store}{e_2} \land \well{\store}{e_3}$
        \item $\well{\store}{\letbind{x}{e_1}{e_2}} \implies \well{\store}{e_1} \land \well{\store}{e_2}$
        \item $\well{\store}{\pi_i\ e} \implies \well{\store}{e}$
        \item $\well{\store}{\return\ e} \implies \well{\store}{e}$
        \item $\well{\store}{\returnLIOp\ e} \implies \well{\store}{e}$
        \item $\well{\store}{e_1\ \diamond\ e_2}  \implies \well{\store}{e_1} \land \well{\store}{e_2}$, where $\diamond = \{\bind, \lub, \glb, \bindLIOp\}$
        \item $\well{\store}{\withLblClr\ e_1\ e_2}  \implies \well{\store}{e_1} \land \well{\store}{e_2}$ % TODO : look over
        \item $\well{\store}{\seal\ e_1\ e_1}        \implies \well{\store}{e_1} \land \well{\store}{e_2}$
        \item $\well{\store}{\open\ (\Lv\ l\ e)} \implies  \well{\store}{e}$
        \item $\well{\store}{\close\ e} \implies \well{\store}{e}$
      \end{enumerate}
\item Inversion of $\mathcal{W}$ on evaluation contexts: $\well{\store}{E[e]} \implies \well{\store}{e}$
\item Inversion of $\mathcal{W}$ under substitution: $\well{\store}{[e_2/x]e_1} \implies \well{\store}{e_1} \land \well{\store}{e_2}$
\end{enumerate}
\end{proposition}
\begin{proof}
\quad
\begin{enumerate}
\item By definition of $\mathcal{W}$ and induction on terms. 
% Add proof for open and seal
\item All follow directly from the definition of $\mathcal{W}$, we highlight the interesting case below:
      \begin{enumerate}
        \item[{\em (o)}] It follows from the definition of $\mathcal{W}$ that $\well{\store}{\open\ (\Lv\ l\ e)} \implies \well{\store^\prime}{e}$
              for some $\store^\prime : {\store^\prime({\lbl}) \flows \store({\lbl})}$.
              As $\store$ is less constrained than $\store^\prime$, it follows from the first
              proposition that ${\well{\store^\prime}{e} \implies \well{\store}{e}}$.
      \end{enumerate}
\item All follow directly from the inversion properties of $\mathcal{W}$, and induction on evaluation contexts and terms.
      Let $e_i: \well{\store}{e_i}$.
      \begin{enumerate}
      \item Let $E := [\cdot]\ e_0$, it follows that\\
            ${\well{\store}{E[e]}= \well{\store}{e\ e_0} \implies \well{\store}{e} \land \well{\store}{e_0} \implies \well{\store}{e}}$
      \item Let $ E := ([\cdot], e_0)$, it follows that \\
            ${\well{\store}{E[e]}= \well{\store}{(e, e_0)} \implies \well{\store}{e} \land \well{\store}{e_0} \implies \well{\store}{e}}$
      \item $ E := (v, [\cdot])$ is as above.
      \item Let $ E := \Lv\ [\cdot]\ e_0$, it follows that \\
            ${\well{\store}{E[e]}= \well{\store}{\Lv\ e\ e_0} \implies \well{\store}{e_0} \land \well{\store}{e} \implies \well{\store}{e}}$
      \item Let $ E := \Lv\ e_0\ [\cdot]$, it follows that \\
            ${\well{\store}{E[e]}= \well{\store}{\Lv\ e_0\ e} \implies \well{\store}{e_0} \land \well{\store}{e} \implies \well{\store}{e}}$
      \item Let $ E := \ifel{[\cdot]}{e_0}{e_1}$, it follows that \\
            ${\well{\store}{E[e]}= \well{\store}{\ifel{e}{e_0}{e_1}} \implies \well{\store}{e} \land \well{\store}{e_0} \land \well{\store}{e_1} \implies \well{\store}{e}}$
      \item Let $ E := \letbind{x}{[\cdot]}{e_0}$, it follows that \\
            ${\well{\store}{E[e]}= \well{\store}{\letbind{x}{e}{e_0}} \implies \well{\store}{e} \land \well{\store}{e_0} \implies \well{\store}{e}}$
      \item Let $ E := \pi_i\ [\cdot]$, it follows that \\
            ${\well{\store}{E[e]}= \well{\store}{\pi_i\ e} \implies \well{\store}{e}}$
      \item Let $ E := \return\ [\cdot]$, it follows that \\
            ${\well{\store}{E[e]}= \well{\store}{\return\ e} \implies \well{\store}{e}}$
      \item $ E := \returnLIOp\ [\cdot]$ is as above.
      \item Let $ E := [\cdot]\ \diamond\ e_0$, for $\diamond = \{\bind, \lub, \glb, \bindLIOp\}$, it follows that \\
            ${\well{\store}{E[e]}= \well{\store}{e\ \diamond\ e_0} \implies \well{\store}{e} \land \well{\store}{e_0} \implies \well{\store}{e}}$
      \item $ E := v\ \diamond\ [\cdot]$, for $\diamond = \{\bind, \lub, \glb, \bindLIOp\}$ is as above.
      \item Let $E := \seal\ [\cdot]\ e_0$, it follows that\\
            ${\well{\store}{E[e]}= \well{\store}{\seal\ e\ e_0} \implies \well{\store}{e} \land \well{\store}{e_0}}$
      \item Let $E := \open\ [\cdot]$, it follows that\\
            ${\well{\store}{E[e]}= \well{\store}{\open\ e} \implies  \well{\store}{e}}$
      \item Let $E := \close\ [\cdot]$, it follows that\\
            ${\well{\store}{E[e]}= \well{\store}{\close\ e} \implies \well{\store}{e}}$
      \end{enumerate}
\item Since information flow control is preserved under substitution, it directly follows from $\well{\store}{(\lambda x .e_1)\ e_2} \implies \well{\store}{e_1} \land \well{\store}{e_2}$ and evaluation rule \tref{E-App}.
\end{enumerate}
\end{proof}


\begin{lemma}[Preservation of pure terms]
If $\vdash e : \tau$ and $e \longrightarrow e^\prime$ then $\vdash e^\prime : \tau$.
\end{lemma}
\begin{proofidea}
Follows directly from the typing deriviatins.
\end{proofidea}

This lemma states that a well-typed term taking an evaluation step results in a term that is also well-typed.



\begin{lemma}[Type and information flow preservation]
\label{lemma:type-flow-preservation-old}
If $\vdash e : \tau$, $\well{\store}{e}$, and $\langle \store, e\rangle \longrightarrow \langle \store^\prime, e^\prime \rangle$ then $\vdash e^\prime : \tau$.
\end{lemma}
\begin{proofidea}
Follows directly from the typing deriviatins, definition of $\mathcal{W}$ and Proposition~\ref{proposition:well}.
\end{proofidea}
A well-typed and well-behaved term taking an evaluation step results in a term that is also well-typed.



\begin{lemma}[Progress of pure terms]
If $\vdash e : \tau$ and $e$ does not depend on an environment (i.e., $e$ does not contain \seal{} or \open{}), then $e \longrightarrow v$, or there exists $e^\prime$ such that $e \longrightarrow e^\prime$.
\end{lemma}
\begin{proofidea}
Follows directly from the typing deriviatins.
\end{proofidea}
This lemma states that a closed and well-typed pure term is not stuck.

\begin{lemma}[Progress of well-typed and well-behaved terms]
Given environment $\store$, if $\vdash e : \tau$ and $\well{\store}{e}$ then $\langle \store, e \rangle \longrightarrow \langle \store^\prime, v\rangle$, or there exists $e^\prime$ such that $\langle \store, e \rangle \longrightarrow \langle \store^\second, e^\prime\rangle$.
\end{lemma}
\begin{proofidea}
Follows directly from the typing deriviatins, definition of $\mathcal{W}$ and Proposition~\ref{proposition:well}.
\end{proofidea}
This lemma states that a well-typed and well-behaved term is either a value or is not stuck. A well-typed term, however, may get``stuck'' if it not well-behaved, i.e., violates information flow.











\end{document} 
